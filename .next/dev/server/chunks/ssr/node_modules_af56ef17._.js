module.exports = [
"[project]/node_modules/next/dist/build/webpack/loaders/next-flight-loader/server-reference.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint-disable import/no-extraneous-dependencies */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "registerServerReference", {
    enumerable: true,
    get: function() {
        return _server.registerServerReference;
    }
});
const _server = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-rsc] (ecmascript)"); //# sourceMappingURL=server-reference.js.map
}),
"[project]/node_modules/@upstash/core-analytics/dist/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var g = Object.defineProperty;
var k = Object.getOwnPropertyDescriptor;
var _ = Object.getOwnPropertyNames;
var y = Object.prototype.hasOwnProperty;
var w = (l, e)=>{
    for(var t in e)g(l, t, {
        get: e[t],
        enumerable: !0
    });
}, A = (l, e, t, i)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let s of _(e))!y.call(l, s) && s !== t && g(l, s, {
        get: ()=>e[s],
        enumerable: !(i = k(e, s)) || i.enumerable
    });
    return l;
};
var x = (l)=>A(g({}, "__esModule", {
        value: !0
    }), l);
var S = {};
w(S, {
    Analytics: ()=>b
});
module.exports = x(S);
var p = `
local key = KEYS[1]
local field = ARGV[1]

local data = redis.call("ZRANGE", key, 0, -1, "WITHSCORES")
local count = {}

for i = 1, #data, 2 do
  local json_str = data[i]
  local score = tonumber(data[i + 1])
  local obj = cjson.decode(json_str)

  local fieldValue = obj[field]

  if count[fieldValue] == nil then
    count[fieldValue] = score
  else
    count[fieldValue] = count[fieldValue] + score
  end
end

local result = {}
for k, v in pairs(count) do
  table.insert(result, {k, v})
end

return result
`, f = `
local prefix = KEYS[1]
local first_timestamp = tonumber(ARGV[1]) -- First timestamp to check
local increment = tonumber(ARGV[2])       -- Increment between each timestamp
local num_timestamps = tonumber(ARGV[3])  -- Number of timestampts to check (24 for a day and 24 * 7 for a week)
local num_elements = tonumber(ARGV[4])    -- Number of elements to fetch in each category
local check_at_most = tonumber(ARGV[5])   -- Number of elements to check at most.

local keys = {}
for i = 1, num_timestamps do
  local timestamp = first_timestamp - (i - 1) * increment
  table.insert(keys, prefix .. ":" .. timestamp)
end

-- get the union of the groups
local zunion_params = {"ZUNION", num_timestamps, unpack(keys)}
table.insert(zunion_params, "WITHSCORES")
local result = redis.call(unpack(zunion_params))

-- select num_elements many items
local true_group = {}
local false_group = {}
local denied_group = {}
local true_count = 0
local false_count = 0
local denied_count = 0
local i = #result - 1

-- index to stop at after going through "checkAtMost" many items:
local cutoff_index = #result - 2 * check_at_most

-- iterate over the results
while (true_count + false_count + denied_count) < (num_elements * 3) and 1 <= i and i >= cutoff_index do
  local score = tonumber(result[i + 1])
  if score > 0 then
    local element = result[i]
    if string.find(element, "success\\":true") and true_count < num_elements then
      table.insert(true_group, {score, element})
      true_count = true_count + 1
    elseif string.find(element, "success\\":false") and false_count < num_elements then
      table.insert(false_group, {score, element})
      false_count = false_count + 1
    elseif string.find(element, "success\\":\\"denied") and denied_count < num_elements then
      table.insert(denied_group, {score, element})
      denied_count = denied_count + 1
    end
  end
  i = i - 2
end

return {true_group, false_group, denied_group}
`, h = `
local prefix = KEYS[1]
local first_timestamp = tonumber(ARGV[1])
local increment = tonumber(ARGV[2])
local num_timestamps = tonumber(ARGV[3])

local keys = {}
for i = 1, num_timestamps do
  local timestamp = first_timestamp - (i - 1) * increment
  table.insert(keys, prefix .. ":" .. timestamp)
end

-- get the union of the groups
local zunion_params = {"ZUNION", num_timestamps, unpack(keys)}
table.insert(zunion_params, "WITHSCORES")
local result = redis.call(unpack(zunion_params))

return result
`;
var b = class {
    redis;
    prefix;
    bucketSize;
    constructor(e){
        this.redis = e.redis, this.prefix = e.prefix ?? "@upstash/analytics", this.bucketSize = this.parseWindow(e.window);
    }
    validateTableName(e) {
        if (!/^[a-zA-Z0-9_-]+$/.test(e)) throw new Error(`Invalid table name: ${e}. Table names can only contain letters, numbers, dashes and underscores.`);
    }
    parseWindow(e) {
        if (typeof e == "number") {
            if (e <= 0) throw new Error(`Invalid window: ${e}`);
            return e;
        }
        let t = /^(\d+)([smhd])$/;
        if (!t.test(e)) throw new Error(`Invalid window: ${e}`);
        let [, i, s] = e.match(t), n = parseInt(i);
        switch(s){
            case "s":
                return n * 1e3;
            case "m":
                return n * 1e3 * 60;
            case "h":
                return n * 1e3 * 60 * 60;
            case "d":
                return n * 1e3 * 60 * 60 * 24;
            default:
                throw new Error(`Invalid window unit: ${s}`);
        }
    }
    getBucket(e) {
        let t = e ?? Date.now();
        return Math.floor(t / this.bucketSize) * this.bucketSize;
    }
    async ingest(e, ...t) {
        this.validateTableName(e), await Promise.all(t.map(async (i)=>{
            let s = this.getBucket(i.time), n = [
                this.prefix,
                e,
                s
            ].join(":");
            await this.redis.zincrby(n, 1, JSON.stringify({
                ...i,
                time: void 0
            }));
        }));
    }
    formatBucketAggregate(e, t, i) {
        let s = {};
        return e.forEach(([n, r])=>{
            t == "success" && (n = n === 1 ? "true" : n === null ? "false" : n), s[t] = s[t] || {}, s[t][(n ?? "null").toString()] = r;
        }), {
            time: i,
            ...s
        };
    }
    async aggregateBucket(e, t, i) {
        this.validateTableName(e);
        let s = this.getBucket(i), n = [
            this.prefix,
            e,
            s
        ].join(":"), r = await this.redis.eval(p, [
            n
        ], [
            t
        ]);
        return this.formatBucketAggregate(r, t, s);
    }
    async aggregateBuckets(e, t, i, s) {
        this.validateTableName(e);
        let n = this.getBucket(s), r = [];
        for(let o = 0; o < i; o += 1)r.push(this.aggregateBucket(e, t, n)), n = n - this.bucketSize;
        return Promise.all(r);
    }
    async aggregateBucketsWithPipeline(e, t, i, s, n) {
        this.validateTableName(e), n = n ?? 48;
        let r = this.getBucket(s), o = [], c = this.redis.pipeline(), u = [];
        for(let a = 1; a <= i; a += 1){
            let d = [
                this.prefix,
                e,
                r
            ].join(":");
            c.eval(p, [
                d
            ], [
                t
            ]), o.push(r), r = r - this.bucketSize, (a % n == 0 || a == i) && (u.push(c.exec()), c = this.redis.pipeline());
        }
        return (await Promise.all(u)).flat().map((a, d)=>this.formatBucketAggregate(a, t, o[d]));
    }
    async getAllowedBlocked(e, t, i) {
        this.validateTableName(e);
        let s = [
            this.prefix,
            e
        ].join(":"), n = this.getBucket(i), r = await this.redis.eval(h, [
            s
        ], [
            n,
            this.bucketSize,
            t
        ]), o = {};
        for(let c = 0; c < r.length; c += 2){
            let u = r[c], m = u.identifier, a = +r[c + 1];
            o[m] || (o[m] = {
                success: 0,
                blocked: 0
            }), o[m][u.success ? "success" : "blocked"] = a;
        }
        return o;
    }
    async getMostAllowedBlocked(e, t, i, s, n) {
        this.validateTableName(e);
        let r = [
            this.prefix,
            e
        ].join(":"), o = this.getBucket(s), c = n ?? i * 5, [u, m, a] = await this.redis.eval(f, [
            r
        ], [
            o,
            this.bucketSize,
            t,
            i,
            c
        ]);
        return {
            allowed: this.toDicts(u),
            ratelimited: this.toDicts(m),
            denied: this.toDicts(a)
        };
    }
    toDicts(e) {
        let t = [];
        for(let i = 0; i < e.length; i += 1){
            let s = +e[i][0], n = e[i][1];
            t.push({
                identifier: n.identifier,
                count: s
            });
        }
        return t;
    }
};
0 && (module.exports = {
    Analytics
});
}),
"[project]/node_modules/@upstash/ratelimit/dist/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var src_exports = {};
__export(src_exports, {
    Analytics: ()=>Analytics,
    IpDenyList: ()=>ip_deny_list_exports,
    MultiRegionRatelimit: ()=>MultiRegionRatelimit,
    Ratelimit: ()=>RegionRatelimit
});
module.exports = __toCommonJS(src_exports);
// src/analytics.ts
var import_core_analytics = __turbopack_context__.r("[project]/node_modules/@upstash/core-analytics/dist/index.js [app-rsc] (ecmascript)");
var Analytics = class {
    analytics;
    table = "events";
    constructor(config){
        this.analytics = new import_core_analytics.Analytics({
            // @ts-expect-error we need to fix the types in core-analytics, it should only require the methods it needs, not the whole sdk
            redis: config.redis,
            window: "1h",
            prefix: config.prefix ?? "@upstash/ratelimit",
            retention: "90d"
        });
    }
    /**
   * Try to extract the geo information from the request
   *
   * This handles Vercel's `req.geo` and  and Cloudflare's `request.cf` properties
   * @param req
   * @returns
   */ extractGeo(req) {
        if (req.geo !== void 0) {
            return req.geo;
        }
        if (req.cf !== void 0) {
            return req.cf;
        }
        return {};
    }
    async record(event) {
        await this.analytics.ingest(this.table, event);
    }
    async series(filter, cutoff) {
        const timestampCount = Math.min((this.analytics.getBucket(Date.now()) - this.analytics.getBucket(cutoff)) / (60 * 60 * 1e3), 256);
        return this.analytics.aggregateBucketsWithPipeline(this.table, filter, timestampCount);
    }
    async getUsage(cutoff = 0) {
        const timestampCount = Math.min((this.analytics.getBucket(Date.now()) - this.analytics.getBucket(cutoff)) / (60 * 60 * 1e3), 256);
        const records = await this.analytics.getAllowedBlocked(this.table, timestampCount);
        return records;
    }
    async getUsageOverTime(timestampCount, groupby) {
        const result = await this.analytics.aggregateBucketsWithPipeline(this.table, groupby, timestampCount);
        return result;
    }
    async getMostAllowedBlocked(timestampCount, getTop, checkAtMost) {
        getTop = getTop ?? 5;
        const timestamp = void 0;
        return this.analytics.getMostAllowedBlocked(this.table, timestampCount, getTop, timestamp, checkAtMost);
    }
};
// src/cache.ts
var Cache = class {
    /**
   * Stores identifier -> reset (in milliseconds)
   */ cache;
    constructor(cache){
        this.cache = cache;
    }
    isBlocked(identifier) {
        if (!this.cache.has(identifier)) {
            return {
                blocked: false,
                reset: 0
            };
        }
        const reset = this.cache.get(identifier);
        if (reset < Date.now()) {
            this.cache.delete(identifier);
            return {
                blocked: false,
                reset: 0
            };
        }
        return {
            blocked: true,
            reset
        };
    }
    blockUntil(identifier, reset) {
        this.cache.set(identifier, reset);
    }
    set(key, value) {
        this.cache.set(key, value);
    }
    get(key) {
        return this.cache.get(key) || null;
    }
    incr(key, incrementAmount = 1) {
        let value = this.cache.get(key) ?? 0;
        value += incrementAmount;
        this.cache.set(key, value);
        return value;
    }
    pop(key) {
        this.cache.delete(key);
    }
    empty() {
        this.cache.clear();
    }
    size() {
        return this.cache.size;
    }
};
// src/duration.ts
function ms(d) {
    const match = d.match(/^(\d+)\s?(ms|s|m|h|d)$/);
    if (!match) {
        throw new Error(`Unable to parse window size: ${d}`);
    }
    const time = Number.parseInt(match[1]);
    const unit = match[2];
    switch(unit){
        case "ms":
            {
                return time;
            }
        case "s":
            {
                return time * 1e3;
            }
        case "m":
            {
                return time * 1e3 * 60;
            }
        case "h":
            {
                return time * 1e3 * 60 * 60;
            }
        case "d":
            {
                return time * 1e3 * 60 * 60 * 24;
            }
        default:
            {
                throw new Error(`Unable to parse window size: ${d}`);
            }
    }
}
// src/hash.ts
var safeEval = async (ctx, script, keys, args)=>{
    try {
        return await ctx.redis.evalsha(script.hash, keys, args);
    } catch (error) {
        if (`${error}`.includes("NOSCRIPT")) {
            return await ctx.redis.eval(script.script, keys, args);
        }
        throw error;
    }
};
// src/lua-scripts/single.ts
var fixedWindowLimitScript = `
  local key           = KEYS[1]
  local window        = ARGV[1]
  local incrementBy   = ARGV[2] -- increment rate per request at a given value, default is 1

  local r = redis.call("INCRBY", key, incrementBy)
  if r == tonumber(incrementBy) then
  -- The first time this key is set, the value will be equal to incrementBy.
  -- So we only need the expire command once
  redis.call("PEXPIRE", key, window)
  end

  return r
`;
var fixedWindowRemainingTokensScript = `
      local key = KEYS[1]
      local tokens = 0

      local value = redis.call('GET', key)
      if value then
          tokens = value
      end
      return tokens
    `;
var slidingWindowLimitScript = `
  local currentKey  = KEYS[1]           -- identifier including prefixes
  local previousKey = KEYS[2]           -- key of the previous bucket
  local tokens      = tonumber(ARGV[1]) -- tokens per window
  local now         = ARGV[2]           -- current timestamp in milliseconds
  local window      = ARGV[3]           -- interval in milliseconds
  local incrementBy = tonumber(ARGV[4]) -- increment rate per request at a given value, default is 1

  local requestsInCurrentWindow = redis.call("GET", currentKey)
  if requestsInCurrentWindow == false then
    requestsInCurrentWindow = 0
  end

  local requestsInPreviousWindow = redis.call("GET", previousKey)
  if requestsInPreviousWindow == false then
    requestsInPreviousWindow = 0
  end
  local percentageInCurrent = ( now % window ) / window
  -- weighted requests to consider from the previous window
  requestsInPreviousWindow = math.floor(( 1 - percentageInCurrent ) * requestsInPreviousWindow)

  -- Only check limit if not refunding (negative rate)
  if incrementBy > 0 and requestsInPreviousWindow + requestsInCurrentWindow >= tokens then
    return -1
  end

  local newValue = redis.call("INCRBY", currentKey, incrementBy)
  if newValue == incrementBy then
    -- The first time this key is set, the value will be equal to incrementBy.
    -- So we only need the expire command once
    redis.call("PEXPIRE", currentKey, window * 2 + 1000) -- Enough time to overlap with a new window + 1 second
  end
  return tokens - ( newValue + requestsInPreviousWindow )
`;
var slidingWindowRemainingTokensScript = `
  local currentKey  = KEYS[1]           -- identifier including prefixes
  local previousKey = KEYS[2]           -- key of the previous bucket
  local now         = ARGV[1]           -- current timestamp in milliseconds
  local window      = ARGV[2]           -- interval in milliseconds

  local requestsInCurrentWindow = redis.call("GET", currentKey)
  if requestsInCurrentWindow == false then
    requestsInCurrentWindow = 0
  end

  local requestsInPreviousWindow = redis.call("GET", previousKey)
  if requestsInPreviousWindow == false then
    requestsInPreviousWindow = 0
  end

  local percentageInCurrent = ( now % window ) / window
  -- weighted requests to consider from the previous window
  requestsInPreviousWindow = math.floor(( 1 - percentageInCurrent ) * requestsInPreviousWindow)

  return requestsInPreviousWindow + requestsInCurrentWindow
`;
var tokenBucketLimitScript = `
  local key         = KEYS[1]           -- identifier including prefixes
  local maxTokens   = tonumber(ARGV[1]) -- maximum number of tokens
  local interval    = tonumber(ARGV[2]) -- size of the window in milliseconds
  local refillRate  = tonumber(ARGV[3]) -- how many tokens are refilled after each interval
  local now         = tonumber(ARGV[4]) -- current timestamp in milliseconds
  local incrementBy = tonumber(ARGV[5]) -- how many tokens to consume, default is 1
        
  local bucket = redis.call("HMGET", key, "refilledAt", "tokens")
        
  local refilledAt
  local tokens

  if bucket[1] == false then
    refilledAt = now
    tokens = maxTokens
  else
    refilledAt = tonumber(bucket[1])
    tokens = tonumber(bucket[2])
  end
        
  if now >= refilledAt + interval then
    local numRefills = math.floor((now - refilledAt) / interval)
    tokens = math.min(maxTokens, tokens + numRefills * refillRate)

    refilledAt = refilledAt + numRefills * interval
  end

  -- Only reject if tokens are 0 and we're consuming (not refunding)
  if tokens == 0 and incrementBy > 0 then
    return {-1, refilledAt + interval}
  end

  local remaining = tokens - incrementBy
  local expireAt = math.ceil(((maxTokens - remaining) / refillRate)) * interval
        
  redis.call("HSET", key, "refilledAt", refilledAt, "tokens", remaining)

  if (expireAt > 0) then
    redis.call("PEXPIRE", key, expireAt)
  end
  return {remaining, refilledAt + interval}
`;
var tokenBucketIdentifierNotFound = -1;
var tokenBucketRemainingTokensScript = `
  local key         = KEYS[1]
  local maxTokens   = tonumber(ARGV[1])
        
  local bucket = redis.call("HMGET", key, "refilledAt", "tokens")

  if bucket[1] == false then
    return {maxTokens, ${tokenBucketIdentifierNotFound}}
  end
        
  return {tonumber(bucket[2]), tonumber(bucket[1])}
`;
var cachedFixedWindowLimitScript = `
  local key     = KEYS[1]
  local window  = ARGV[1]
  local incrementBy   = ARGV[2] -- increment rate per request at a given value, default is 1

  local r = redis.call("INCRBY", key, incrementBy)
  if r == incrementBy then
  -- The first time this key is set, the value will be equal to incrementBy.
  -- So we only need the expire command once
  redis.call("PEXPIRE", key, window)
  end
      
  return r
`;
var cachedFixedWindowRemainingTokenScript = `
  local key = KEYS[1]
  local tokens = 0

  local value = redis.call('GET', key)
  if value then
      tokens = value
  end
  return tokens
`;
// src/lua-scripts/multi.ts
var fixedWindowLimitScript2 = `
	local key           = KEYS[1]
	local id            = ARGV[1]
	local window        = ARGV[2]
	local incrementBy   = tonumber(ARGV[3])

	redis.call("HSET", key, id, incrementBy)
	local fields = redis.call("HGETALL", key)
	if #fields == 2 and tonumber(fields[2])==incrementBy then
	-- The first time this key is set, and the value will be equal to incrementBy.
	-- So we only need the expire command once
	  redis.call("PEXPIRE", key, window)
	end

	return fields
`;
var fixedWindowRemainingTokensScript2 = `
      local key = KEYS[1]
      local tokens = 0

      local fields = redis.call("HGETALL", key)

      return fields
    `;
var slidingWindowLimitScript2 = `
	local currentKey    = KEYS[1]           -- identifier including prefixes
	local previousKey   = KEYS[2]           -- key of the previous bucket
	local tokens        = tonumber(ARGV[1]) -- tokens per window
	local now           = ARGV[2]           -- current timestamp in milliseconds
	local window        = ARGV[3]           -- interval in milliseconds
	local requestId     = ARGV[4]           -- uuid for this request
	local incrementBy   = tonumber(ARGV[5]) -- custom rate, default is  1

	local currentFields = redis.call("HGETALL", currentKey)
	local requestsInCurrentWindow = 0
	for i = 2, #currentFields, 2 do
	requestsInCurrentWindow = requestsInCurrentWindow + tonumber(currentFields[i])
	end

	local previousFields = redis.call("HGETALL", previousKey)
	local requestsInPreviousWindow = 0
	for i = 2, #previousFields, 2 do
	requestsInPreviousWindow = requestsInPreviousWindow + tonumber(previousFields[i])
	end

	local percentageInCurrent = ( now % window) / window

	-- Only check limit if not refunding (negative rate)
	if incrementBy > 0 and requestsInPreviousWindow * (1 - percentageInCurrent ) + requestsInCurrentWindow + incrementBy > tokens then
	  return {currentFields, previousFields, false}
	end

	redis.call("HSET", currentKey, requestId, incrementBy)

	if requestsInCurrentWindow == 0 then 
	  -- The first time this key is set, the value will be equal to incrementBy.
	  -- So we only need the expire command once
	  redis.call("PEXPIRE", currentKey, window * 2 + 1000) -- Enough time to overlap with a new window + 1 second
	end
	return {currentFields, previousFields, true}
`;
var slidingWindowRemainingTokensScript2 = `
	local currentKey    = KEYS[1]           -- identifier including prefixes
	local previousKey   = KEYS[2]           -- key of the previous bucket
	local now         	= ARGV[1]           -- current timestamp in milliseconds
  	local window      	= ARGV[2]           -- interval in milliseconds

	local currentFields = redis.call("HGETALL", currentKey)
	local requestsInCurrentWindow = 0
	for i = 2, #currentFields, 2 do
	requestsInCurrentWindow = requestsInCurrentWindow + tonumber(currentFields[i])
	end

	local previousFields = redis.call("HGETALL", previousKey)
	local requestsInPreviousWindow = 0
	for i = 2, #previousFields, 2 do
	requestsInPreviousWindow = requestsInPreviousWindow + tonumber(previousFields[i])
	end

	local percentageInCurrent = ( now % window) / window
  	requestsInPreviousWindow = math.floor(( 1 - percentageInCurrent ) * requestsInPreviousWindow)
	
	return requestsInCurrentWindow + requestsInPreviousWindow
`;
// src/lua-scripts/reset.ts
var resetScript = `
      local pattern = KEYS[1]

      -- Initialize cursor to start from 0
      local cursor = "0"

      repeat
          -- Scan for keys matching the pattern
          local scan_result = redis.call('SCAN', cursor, 'MATCH', pattern)

          -- Extract cursor for the next iteration
          cursor = scan_result[1]

          -- Extract keys from the scan result
          local keys = scan_result[2]

          for i=1, #keys do
          redis.call('DEL', keys[i])
          end

      -- Continue scanning until cursor is 0 (end of keyspace)
      until cursor == "0"
    `;
// src/lua-scripts/hash.ts
var SCRIPTS = {
    singleRegion: {
        fixedWindow: {
            limit: {
                script: fixedWindowLimitScript,
                hash: "b13943e359636db027ad280f1def143f02158c13"
            },
            getRemaining: {
                script: fixedWindowRemainingTokensScript,
                hash: "8c4c341934502aee132643ffbe58ead3450e5208"
            }
        },
        slidingWindow: {
            limit: {
                script: slidingWindowLimitScript,
                hash: "9b7842963bd73721f1a3011650c23c0010848ee3"
            },
            getRemaining: {
                script: slidingWindowRemainingTokensScript,
                hash: "65a73ac5a05bf9712903bc304b77268980c1c417"
            }
        },
        tokenBucket: {
            limit: {
                script: tokenBucketLimitScript,
                hash: "d1f857ebbdaeca90ccd2cd4eada61d7c8e5db1ca"
            },
            getRemaining: {
                script: tokenBucketRemainingTokensScript,
                hash: "a15be2bb1db2a15f7c82db06146f9d08983900d0"
            }
        },
        cachedFixedWindow: {
            limit: {
                script: cachedFixedWindowLimitScript,
                hash: "c26b12703dd137939b9a69a3a9b18e906a2d940f"
            },
            getRemaining: {
                script: cachedFixedWindowRemainingTokenScript,
                hash: "8e8f222ccae68b595ee6e3f3bf2199629a62b91a"
            }
        }
    },
    multiRegion: {
        fixedWindow: {
            limit: {
                script: fixedWindowLimitScript2,
                hash: "a8c14f3835aa87bd70e5e2116081b81664abcf5c"
            },
            getRemaining: {
                script: fixedWindowRemainingTokensScript2,
                hash: "8ab8322d0ed5fe5ac8eb08f0c2e4557f1b4816fd"
            }
        },
        slidingWindow: {
            limit: {
                script: slidingWindowLimitScript2,
                hash: "1e7ca8dcd2d600a6d0124a67a57ea225ed62921b"
            },
            getRemaining: {
                script: slidingWindowRemainingTokensScript2,
                hash: "558c9306b7ec54abb50747fe0b17e5d44bd24868"
            }
        }
    }
};
var RESET_SCRIPT = {
    script: resetScript,
    hash: "54bd274ddc59fb3be0f42deee2f64322a10e2b50"
};
// src/types.ts
var DenyListExtension = "denyList";
var IpDenyListKey = "ipDenyList";
var IpDenyListStatusKey = "ipDenyListStatus";
// src/deny-list/scripts.ts
var checkDenyListScript = `
  -- Checks if values provideed in ARGV are present in the deny lists.
  -- This is done using the allDenyListsKey below.

  -- Additionally, checks the status of the ip deny list using the
  -- ipDenyListStatusKey below. Here are the possible states of the
  -- ipDenyListStatusKey key:
  -- * status == -1: set to "disabled" with no TTL
  -- * status == -2: not set, meaning that is was set before but expired
  -- * status  >  0: set to "valid", with a TTL
  --
  -- In the case of status == -2, we set the status to "pending" with
  -- 30 second ttl. During this time, the process which got status == -2
  -- will update the ip deny list.

  local allDenyListsKey     = KEYS[1]
  local ipDenyListStatusKey = KEYS[2]

  local results = redis.call('SMISMEMBER', allDenyListsKey, unpack(ARGV))
  local status  = redis.call('TTL', ipDenyListStatusKey)
  if status == -2 then
    redis.call('SETEX', ipDenyListStatusKey, 30, "pending")
  end

  return { results, status }
`;
// src/deny-list/ip-deny-list.ts
var ip_deny_list_exports = {};
__export(ip_deny_list_exports, {
    ThresholdError: ()=>ThresholdError,
    disableIpDenyList: ()=>disableIpDenyList,
    updateIpDenyList: ()=>updateIpDenyList
});
// src/deny-list/time.ts
var MILLISECONDS_IN_HOUR = 60 * 60 * 1e3;
var MILLISECONDS_IN_DAY = 24 * MILLISECONDS_IN_HOUR;
var MILLISECONDS_TO_2AM = 2 * MILLISECONDS_IN_HOUR;
var getIpListTTL = (time)=>{
    const now = time || Date.now();
    const timeSinceLast2AM = (now - MILLISECONDS_TO_2AM) % MILLISECONDS_IN_DAY;
    return MILLISECONDS_IN_DAY - timeSinceLast2AM;
};
// src/deny-list/ip-deny-list.ts
var baseUrl = "https://raw.githubusercontent.com/stamparm/ipsum/master/levels";
var ThresholdError = class extends Error {
    constructor(threshold){
        super(`Allowed threshold values are from 1 to 8, 1 and 8 included. Received: ${threshold}`);
        this.name = "ThresholdError";
    }
};
var getIpDenyList = async (threshold)=>{
    if (typeof threshold !== "number" || threshold < 1 || threshold > 8) {
        throw new ThresholdError(threshold);
    }
    try {
        const response = await fetch(`${baseUrl}/${threshold}.txt`);
        if (!response.ok) {
            throw new Error(`Error fetching data: ${response.statusText}`);
        }
        const data = await response.text();
        const lines = data.split("\n");
        return lines.filter((value)=>value.length > 0);
    } catch (error) {
        throw new Error(`Failed to fetch ip deny list: ${error}`);
    }
};
var updateIpDenyList = async (redis, prefix, threshold, ttl)=>{
    const allIps = await getIpDenyList(threshold);
    const allDenyLists = [
        prefix,
        DenyListExtension,
        "all"
    ].join(":");
    const ipDenyList = [
        prefix,
        DenyListExtension,
        IpDenyListKey
    ].join(":");
    const statusKey = [
        prefix,
        IpDenyListStatusKey
    ].join(":");
    const transaction = redis.multi();
    transaction.sdiffstore(allDenyLists, allDenyLists, ipDenyList);
    transaction.del(ipDenyList);
    transaction.sadd(ipDenyList, allIps.at(0), ...allIps.slice(1));
    transaction.sdiffstore(ipDenyList, ipDenyList, allDenyLists);
    transaction.sunionstore(allDenyLists, allDenyLists, ipDenyList);
    transaction.set(statusKey, "valid", {
        px: ttl ?? getIpListTTL()
    });
    return await transaction.exec();
};
var disableIpDenyList = async (redis, prefix)=>{
    const allDenyListsKey = [
        prefix,
        DenyListExtension,
        "all"
    ].join(":");
    const ipDenyListKey = [
        prefix,
        DenyListExtension,
        IpDenyListKey
    ].join(":");
    const statusKey = [
        prefix,
        IpDenyListStatusKey
    ].join(":");
    const transaction = redis.multi();
    transaction.sdiffstore(allDenyListsKey, allDenyListsKey, ipDenyListKey);
    transaction.del(ipDenyListKey);
    transaction.set(statusKey, "disabled");
    return await transaction.exec();
};
// src/deny-list/deny-list.ts
var denyListCache = new Cache(/* @__PURE__ */ new Map());
var checkDenyListCache = (members)=>{
    return members.find((member)=>denyListCache.isBlocked(member).blocked);
};
var blockMember = (member)=>{
    if (denyListCache.size() > 1e3) denyListCache.empty();
    denyListCache.blockUntil(member, Date.now() + 6e4);
};
var checkDenyList = async (redis, prefix, members)=>{
    const [deniedValues, ipDenyListStatus] = await redis.eval(checkDenyListScript, [
        [
            prefix,
            DenyListExtension,
            "all"
        ].join(":"),
        [
            prefix,
            IpDenyListStatusKey
        ].join(":")
    ], members);
    let deniedValue = void 0;
    deniedValues.map((memberDenied, index)=>{
        if (memberDenied) {
            blockMember(members[index]);
            deniedValue = members[index];
        }
    });
    return {
        deniedValue,
        invalidIpDenyList: ipDenyListStatus === -2
    };
};
var resolveLimitPayload = (redis, prefix, [ratelimitResponse, denyListResponse], threshold)=>{
    if (denyListResponse.deniedValue) {
        ratelimitResponse.success = false;
        ratelimitResponse.remaining = 0;
        ratelimitResponse.reason = "denyList";
        ratelimitResponse.deniedValue = denyListResponse.deniedValue;
    }
    if (denyListResponse.invalidIpDenyList) {
        const updatePromise = updateIpDenyList(redis, prefix, threshold);
        ratelimitResponse.pending = Promise.all([
            ratelimitResponse.pending,
            updatePromise
        ]);
    }
    return ratelimitResponse;
};
var defaultDeniedResponse = (deniedValue)=>{
    return {
        success: false,
        limit: 0,
        remaining: 0,
        reset: 0,
        pending: Promise.resolve(),
        reason: "denyList",
        deniedValue
    };
};
// src/ratelimit.ts
var Ratelimit = class {
    limiter;
    ctx;
    prefix;
    timeout;
    primaryRedis;
    analytics;
    enableProtection;
    denyListThreshold;
    constructor(config){
        this.ctx = config.ctx;
        this.limiter = config.limiter;
        this.timeout = config.timeout ?? 5e3;
        this.prefix = config.prefix ?? "@upstash/ratelimit";
        this.enableProtection = config.enableProtection ?? false;
        this.denyListThreshold = config.denyListThreshold ?? 6;
        this.primaryRedis = "redis" in this.ctx ? this.ctx.redis : this.ctx.regionContexts[0].redis;
        this.analytics = config.analytics ? new Analytics({
            redis: this.primaryRedis,
            prefix: this.prefix
        }) : void 0;
        if (config.ephemeralCache instanceof Map) {
            this.ctx.cache = new Cache(config.ephemeralCache);
        } else if (config.ephemeralCache === void 0) {
            this.ctx.cache = new Cache(/* @__PURE__ */ new Map());
        }
    }
    /**
   * Determine if a request should pass or be rejected based on the identifier and previously chosen ratelimit.
   *
   * Use this if you want to reject all requests that you can not handle right now.
   *
   * @example
   * ```ts
   *  const ratelimit = new Ratelimit({
   *    redis: Redis.fromEnv(),
   *    limiter: Ratelimit.slidingWindow(10, "10 s")
   *  })
   *
   *  const { success } = await ratelimit.limit(id)
   *  if (!success){
   *    return "Nope"
   *  }
   *  return "Yes"
   * ```
   *
   * @param req.rate - The rate at which tokens will be added or consumed from the token bucket. A higher rate allows for more requests to be processed. Defaults to 1 token per interval if not specified.
   *
   * Usage with `req.rate`
   * @example
   * ```ts
   *  const ratelimit = new Ratelimit({
   *    redis: Redis.fromEnv(),
   *    limiter: Ratelimit.slidingWindow(100, "10 s")
   *  })
   *
   *  const { success } = await ratelimit.limit(id, {rate: 10})
   *  if (!success){
   *    return "Nope"
   *  }
   *  return "Yes"
   * ```
   */ limit = async (identifier, req)=>{
        let timeoutId = null;
        try {
            const response = this.getRatelimitResponse(identifier, req);
            const { responseArray, newTimeoutId } = this.applyTimeout(response);
            timeoutId = newTimeoutId;
            const timedResponse = await Promise.race(responseArray);
            const finalResponse = this.submitAnalytics(timedResponse, identifier, req);
            return finalResponse;
        } finally{
            if (timeoutId) {
                clearTimeout(timeoutId);
            }
        }
    };
    /**
   * Block until the request may pass or timeout is reached.
   *
   * This method returns a promise that resolves as soon as the request may be processed
   * or after the timeout has been reached.
   *
   * Use this if you want to delay the request until it is ready to get processed.
   *
   * @example
   * ```ts
   *  const ratelimit = new Ratelimit({
   *    redis: Redis.fromEnv(),
   *    limiter: Ratelimit.slidingWindow(10, "10 s")
   *  })
   *
   *  const { success } = await ratelimit.blockUntilReady(id, 60_000)
   *  if (!success){
   *    return "Nope"
   *  }
   *  return "Yes"
   * ```
   */ blockUntilReady = async (identifier, timeout)=>{
        if (timeout <= 0) {
            throw new Error("timeout must be positive");
        }
        let res;
        const deadline = Date.now() + timeout;
        while(true){
            res = await this.limit(identifier);
            if (res.success) {
                break;
            }
            if (res.reset === 0) {
                throw new Error("This should not happen");
            }
            const wait = Math.min(res.reset, deadline) - Date.now();
            await new Promise((r)=>setTimeout(r, wait));
            if (Date.now() > deadline) {
                break;
            }
        }
        return res;
    };
    resetUsedTokens = async (identifier)=>{
        const pattern = [
            this.prefix,
            identifier
        ].join(":");
        await this.limiter().resetTokens(this.ctx, pattern);
    };
    /**
   * Returns the remaining token count together with a reset timestamps
   * 
   * @param identifier identifir to check
   * @returns object with `remaining` and reset fields. `remaining` denotes
   *          the remaining tokens and reset denotes the timestamp when the
   *          tokens reset.
   */ getRemaining = async (identifier)=>{
        const pattern = [
            this.prefix,
            identifier
        ].join(":");
        return await this.limiter().getRemaining(this.ctx, pattern);
    };
    /**
   * Checks if the identifier or the values in req are in the deny list cache.
   * If so, returns the default denied response.
   * 
   * Otherwise, calls redis to check the rate limit and deny list. Returns after
   * resolving the result. Resolving is overriding the rate limit result if
   * the some value is in deny list.
   * 
   * @param identifier identifier to block
   * @param req options with ip, user agent, country, rate and geo info
   * @returns rate limit response
   */ getRatelimitResponse = async (identifier, req)=>{
        const key = this.getKey(identifier);
        const definedMembers = this.getDefinedMembers(identifier, req);
        const deniedValue = checkDenyListCache(definedMembers);
        const result = deniedValue ? [
            defaultDeniedResponse(deniedValue),
            {
                deniedValue,
                invalidIpDenyList: false
            }
        ] : await Promise.all([
            this.limiter().limit(this.ctx, key, req?.rate),
            this.enableProtection ? checkDenyList(this.primaryRedis, this.prefix, definedMembers) : {
                deniedValue: void 0,
                invalidIpDenyList: false
            }
        ]);
        return resolveLimitPayload(this.primaryRedis, this.prefix, result, this.denyListThreshold);
    };
    /**
   * Creates an array with the original response promise and a timeout promise
   * if this.timeout > 0.
   * 
   * @param response Ratelimit response promise
   * @returns array with the response and timeout promise. also includes the timeout id
   */ applyTimeout = (response)=>{
        let newTimeoutId = null;
        const responseArray = [
            response
        ];
        if (this.timeout > 0) {
            const timeoutResponse = new Promise((resolve)=>{
                newTimeoutId = setTimeout(()=>{
                    resolve({
                        success: true,
                        limit: 0,
                        remaining: 0,
                        reset: 0,
                        pending: Promise.resolve(),
                        reason: "timeout"
                    });
                }, this.timeout);
            });
            responseArray.push(timeoutResponse);
        }
        return {
            responseArray,
            newTimeoutId
        };
    };
    /**
   * submits analytics if this.analytics is set
   * 
   * @param ratelimitResponse final rate limit response
   * @param identifier identifier to submit
   * @param req limit options
   * @returns rate limit response after updating the .pending field
   */ submitAnalytics = (ratelimitResponse, identifier, req)=>{
        if (this.analytics) {
            try {
                const geo = req ? this.analytics.extractGeo(req) : void 0;
                const analyticsP = this.analytics.record({
                    identifier: ratelimitResponse.reason === "denyList" ? ratelimitResponse.deniedValue : identifier,
                    time: Date.now(),
                    success: ratelimitResponse.reason === "denyList" ? "denied" : ratelimitResponse.success,
                    ...geo
                }).catch((error)=>{
                    let errorMessage = "Failed to record analytics";
                    if (`${error}`.includes("WRONGTYPE")) {
                        errorMessage = `
    Failed to record analytics. See the information below:

    This can occur when you uprade to Ratelimit version 1.1.2
    or later from an earlier version.

    This occurs simply because the way we store analytics data
    has changed. To avoid getting this error, disable analytics
    for *an hour*, then simply enable it back.

    `;
                    }
                    console.warn(errorMessage, error);
                });
                ratelimitResponse.pending = Promise.all([
                    ratelimitResponse.pending,
                    analyticsP
                ]);
            } catch (error) {
                console.warn("Failed to record analytics", error);
            }
            ;
        }
        ;
        return ratelimitResponse;
    };
    getKey = (identifier)=>{
        return [
            this.prefix,
            identifier
        ].join(":");
    };
    /**
   * returns a list of defined values from
   * [identifier, req.ip, req.userAgent, req.country]
   * 
   * @param identifier identifier
   * @param req limit options
   * @returns list of defined values
   */ getDefinedMembers = (identifier, req)=>{
        const members = [
            identifier,
            req?.ip,
            req?.userAgent,
            req?.country
        ];
        return members.filter(Boolean);
    };
};
// src/multi.ts
function randomId() {
    let result = "";
    const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    const charactersLength = characters.length;
    for(let i = 0; i < 16; i++){
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
}
var MultiRegionRatelimit = class extends Ratelimit {
    /**
   * Create a new Ratelimit instance by providing a `@upstash/redis` instance and the algorithn of your choice.
   */ constructor(config){
        super({
            prefix: config.prefix,
            limiter: config.limiter,
            timeout: config.timeout,
            analytics: config.analytics,
            ctx: {
                regionContexts: config.redis.map((redis)=>({
                        redis
                    })),
                cache: config.ephemeralCache ? new Cache(config.ephemeralCache) : void 0
            }
        });
    }
    /**
   * Each request inside a fixed time increases a counter.
   * Once the counter reaches the maximum allowed number, all further requests are
   * rejected.
   *
   * **Pro:**
   *
   * - Newer requests are not starved by old ones.
   * - Low storage cost.
   *
   * **Con:**
   *
   * A burst of requests near the boundary of a window can result in a very
   * high request rate because two windows will be filled with requests quickly.
   *
   * @param tokens - How many requests a user can make in each time window.
   * @param window - A fixed timeframe
   */ static fixedWindow(tokens, window) {
        const windowDuration = ms(window);
        return ()=>({
                async limit (ctx, identifier, rate) {
                    const requestId = randomId();
                    const bucket = Math.floor(Date.now() / windowDuration);
                    const key = [
                        identifier,
                        bucket
                    ].join(":");
                    const incrementBy = rate ?? 1;
                    if (ctx.cache && incrementBy > 0) {
                        const { blocked, reset: reset2 } = ctx.cache.isBlocked(identifier);
                        if (blocked) {
                            return {
                                success: false,
                                limit: tokens,
                                remaining: 0,
                                reset: reset2,
                                pending: Promise.resolve(),
                                reason: "cacheBlock"
                            };
                        }
                    }
                    const dbs = ctx.regionContexts.map((regionContext)=>({
                            redis: regionContext.redis,
                            request: safeEval(regionContext, SCRIPTS.multiRegion.fixedWindow.limit, [
                                key
                            ], [
                                requestId,
                                windowDuration,
                                incrementBy
                            ])
                        }));
                    const firstResponse = await Promise.any(dbs.map((s)=>s.request));
                    const usedTokens = firstResponse.reduce((accTokens, usedToken, index)=>{
                        let parsedToken = 0;
                        if (index % 2) {
                            parsedToken = Number.parseInt(usedToken);
                        }
                        return accTokens + parsedToken;
                    }, 0);
                    const remaining = tokens - usedTokens;
                    async function sync() {
                        const individualIDs = await Promise.all(dbs.map((s)=>s.request));
                        const allIDs = [
                            ...new Set(individualIDs.flat().reduce((acc, curr, index)=>{
                                if (index % 2 === 0) {
                                    acc.push(curr);
                                }
                                return acc;
                            }, [])).values()
                        ];
                        for (const db of dbs){
                            const usedDbTokensRequest = await db.request;
                            const usedDbTokens = usedDbTokensRequest.reduce((accTokens, usedToken, index)=>{
                                let parsedToken = 0;
                                if (index % 2) {
                                    parsedToken = Number.parseInt(usedToken);
                                }
                                return accTokens + parsedToken;
                            }, 0);
                            const dbIdsRequest = await db.request;
                            const dbIds = dbIdsRequest.reduce((ids, currentId, index)=>{
                                if (index % 2 === 0) {
                                    ids.push(currentId);
                                }
                                return ids;
                            }, []);
                            if (usedDbTokens >= tokens) {
                                continue;
                            }
                            const diff = allIDs.filter((id)=>!dbIds.includes(id));
                            if (diff.length === 0) {
                                continue;
                            }
                            for (const requestId2 of diff){
                                await db.redis.hset(key, {
                                    [requestId2]: incrementBy
                                });
                            }
                        }
                    }
                    const success = remaining >= 0;
                    const reset = (bucket + 1) * windowDuration;
                    if (ctx.cache) {
                        if (!success) {
                            ctx.cache.blockUntil(identifier, reset);
                        } else if (incrementBy < 0) {
                            ctx.cache.pop(identifier);
                        }
                    }
                    return {
                        success,
                        limit: tokens,
                        remaining,
                        reset,
                        pending: sync()
                    };
                },
                async getRemaining (ctx, identifier) {
                    const bucket = Math.floor(Date.now() / windowDuration);
                    const key = [
                        identifier,
                        bucket
                    ].join(":");
                    const dbs = ctx.regionContexts.map((regionContext)=>({
                            redis: regionContext.redis,
                            request: safeEval(regionContext, SCRIPTS.multiRegion.fixedWindow.getRemaining, [
                                key
                            ], [
                                null
                            ])
                        }));
                    const firstResponse = await Promise.any(dbs.map((s)=>s.request));
                    const usedTokens = firstResponse.reduce((accTokens, usedToken, index)=>{
                        let parsedToken = 0;
                        if (index % 2) {
                            parsedToken = Number.parseInt(usedToken);
                        }
                        return accTokens + parsedToken;
                    }, 0);
                    return {
                        remaining: Math.max(0, tokens - usedTokens),
                        reset: (bucket + 1) * windowDuration
                    };
                },
                async resetTokens (ctx, identifier) {
                    const pattern = [
                        identifier,
                        "*"
                    ].join(":");
                    if (ctx.cache) {
                        ctx.cache.pop(identifier);
                    }
                    await Promise.all(ctx.regionContexts.map((regionContext)=>{
                        safeEval(regionContext, RESET_SCRIPT, [
                            pattern
                        ], [
                            null
                        ]);
                    }));
                }
            });
    }
    /**
   * Combined approach of `slidingLogs` and `fixedWindow` with lower storage
   * costs than `slidingLogs` and improved boundary behavior by calculating a
   * weighted score between two windows.
   *
   * **Pro:**
   *
   * Good performance allows this to scale to very high loads.
   *
   * **Con:**
   *
   * Nothing major.
   *
   * @param tokens - How many requests a user can make in each time window.
   * @param window - The duration in which the user can max X requests.
   */ static slidingWindow(tokens, window) {
        const windowSize = ms(window);
        const windowDuration = ms(window);
        return ()=>({
                async limit (ctx, identifier, rate) {
                    const requestId = randomId();
                    const now = Date.now();
                    const currentWindow = Math.floor(now / windowSize);
                    const currentKey = [
                        identifier,
                        currentWindow
                    ].join(":");
                    const previousWindow = currentWindow - 1;
                    const previousKey = [
                        identifier,
                        previousWindow
                    ].join(":");
                    const incrementBy = rate ?? 1;
                    if (ctx.cache && incrementBy > 0) {
                        const { blocked, reset: reset2 } = ctx.cache.isBlocked(identifier);
                        if (blocked) {
                            return {
                                success: false,
                                limit: tokens,
                                remaining: 0,
                                reset: reset2,
                                pending: Promise.resolve(),
                                reason: "cacheBlock"
                            };
                        }
                    }
                    const dbs = ctx.regionContexts.map((regionContext)=>({
                            redis: regionContext.redis,
                            request: safeEval(regionContext, SCRIPTS.multiRegion.slidingWindow.limit, [
                                currentKey,
                                previousKey
                            ], [
                                tokens,
                                now,
                                windowDuration,
                                requestId,
                                incrementBy
                            ])
                        }));
                    const percentageInCurrent = now % windowDuration / windowDuration;
                    const [current, previous, success] = await Promise.any(dbs.map((s)=>s.request));
                    if (success) {
                        current.push(requestId, incrementBy.toString());
                    }
                    const previousUsedTokens = previous.reduce((accTokens, usedToken, index)=>{
                        let parsedToken = 0;
                        if (index % 2) {
                            parsedToken = Number.parseInt(usedToken);
                        }
                        return accTokens + parsedToken;
                    }, 0);
                    const currentUsedTokens = current.reduce((accTokens, usedToken, index)=>{
                        let parsedToken = 0;
                        if (index % 2) {
                            parsedToken = Number.parseInt(usedToken);
                        }
                        return accTokens + parsedToken;
                    }, 0);
                    const previousPartialUsed = Math.ceil(previousUsedTokens * (1 - percentageInCurrent));
                    const usedTokens = previousPartialUsed + currentUsedTokens;
                    const remaining = tokens - usedTokens;
                    async function sync() {
                        const res = await Promise.all(dbs.map((s)=>s.request));
                        const allCurrentIds = [
                            ...new Set(res.flatMap(([current2])=>current2).reduce((acc, curr, index)=>{
                                if (index % 2 === 0) {
                                    acc.push(curr);
                                }
                                return acc;
                            }, [])).values()
                        ];
                        for (const db of dbs){
                            const [current2, _previous, _success] = await db.request;
                            const dbIds = current2.reduce((ids, currentId, index)=>{
                                if (index % 2 === 0) {
                                    ids.push(currentId);
                                }
                                return ids;
                            }, []);
                            const usedDbTokens = current2.reduce((accTokens, usedToken, index)=>{
                                let parsedToken = 0;
                                if (index % 2) {
                                    parsedToken = Number.parseInt(usedToken);
                                }
                                return accTokens + parsedToken;
                            }, 0);
                            if (usedDbTokens >= tokens) {
                                continue;
                            }
                            const diff = allCurrentIds.filter((id)=>!dbIds.includes(id));
                            if (diff.length === 0) {
                                continue;
                            }
                            for (const requestId2 of diff){
                                await db.redis.hset(currentKey, {
                                    [requestId2]: incrementBy
                                });
                            }
                        }
                    }
                    const reset = (currentWindow + 1) * windowDuration;
                    if (ctx.cache) {
                        if (!success) {
                            ctx.cache.blockUntil(identifier, reset);
                        } else if (incrementBy < 0) {
                            ctx.cache.pop(identifier);
                        }
                    }
                    return {
                        success: Boolean(success),
                        limit: tokens,
                        remaining: Math.max(0, remaining),
                        reset,
                        pending: sync()
                    };
                },
                async getRemaining (ctx, identifier) {
                    const now = Date.now();
                    const currentWindow = Math.floor(now / windowSize);
                    const currentKey = [
                        identifier,
                        currentWindow
                    ].join(":");
                    const previousWindow = currentWindow - 1;
                    const previousKey = [
                        identifier,
                        previousWindow
                    ].join(":");
                    const dbs = ctx.regionContexts.map((regionContext)=>({
                            redis: regionContext.redis,
                            request: safeEval(regionContext, SCRIPTS.multiRegion.slidingWindow.getRemaining, [
                                currentKey,
                                previousKey
                            ], [
                                now,
                                windowSize
                            ])
                        }));
                    const usedTokens = await Promise.any(dbs.map((s)=>s.request));
                    return {
                        remaining: Math.max(0, tokens - usedTokens),
                        reset: (currentWindow + 1) * windowSize
                    };
                },
                async resetTokens (ctx, identifier) {
                    const pattern = [
                        identifier,
                        "*"
                    ].join(":");
                    if (ctx.cache) {
                        ctx.cache.pop(identifier);
                    }
                    await Promise.all(ctx.regionContexts.map((regionContext)=>{
                        safeEval(regionContext, RESET_SCRIPT, [
                            pattern
                        ], [
                            null
                        ]);
                    }));
                }
            });
    }
};
// src/single.ts
var RegionRatelimit = class extends Ratelimit {
    /**
   * Create a new Ratelimit instance by providing a `@upstash/redis` instance and the algorithm of your choice.
   */ constructor(config){
        super({
            prefix: config.prefix,
            limiter: config.limiter,
            timeout: config.timeout,
            analytics: config.analytics,
            ctx: {
                redis: config.redis
            },
            ephemeralCache: config.ephemeralCache,
            enableProtection: config.enableProtection,
            denyListThreshold: config.denyListThreshold
        });
    }
    /**
   * Each request inside a fixed time increases a counter.
   * Once the counter reaches the maximum allowed number, all further requests are
   * rejected.
   *
   * **Pro:**
   *
   * - Newer requests are not starved by old ones.
   * - Low storage cost.
   *
   * **Con:**
   *
   * A burst of requests near the boundary of a window can result in a very
   * high request rate because two windows will be filled with requests quickly.
   *
   * @param tokens - How many requests a user can make in each time window.
   * @param window - A fixed timeframe
   */ static fixedWindow(tokens, window) {
        const windowDuration = ms(window);
        return ()=>({
                async limit (ctx, identifier, rate) {
                    const bucket = Math.floor(Date.now() / windowDuration);
                    const key = [
                        identifier,
                        bucket
                    ].join(":");
                    const incrementBy = rate ?? 1;
                    if (ctx.cache && incrementBy > 0) {
                        const { blocked, reset: reset2 } = ctx.cache.isBlocked(identifier);
                        if (blocked) {
                            return {
                                success: false,
                                limit: tokens,
                                remaining: 0,
                                reset: reset2,
                                pending: Promise.resolve(),
                                reason: "cacheBlock"
                            };
                        }
                    }
                    const usedTokensAfterUpdate = await safeEval(ctx, SCRIPTS.singleRegion.fixedWindow.limit, [
                        key
                    ], [
                        windowDuration,
                        incrementBy
                    ]);
                    const success = usedTokensAfterUpdate <= tokens;
                    const remainingTokens = Math.max(0, tokens - usedTokensAfterUpdate);
                    const reset = (bucket + 1) * windowDuration;
                    if (ctx.cache) {
                        if (!success) {
                            ctx.cache.blockUntil(identifier, reset);
                        } else if (incrementBy < 0) {
                            ctx.cache.pop(identifier);
                        }
                    }
                    return {
                        success,
                        limit: tokens,
                        remaining: remainingTokens,
                        reset,
                        pending: Promise.resolve()
                    };
                },
                async getRemaining (ctx, identifier) {
                    const bucket = Math.floor(Date.now() / windowDuration);
                    const key = [
                        identifier,
                        bucket
                    ].join(":");
                    const usedTokens = await safeEval(ctx, SCRIPTS.singleRegion.fixedWindow.getRemaining, [
                        key
                    ], [
                        null
                    ]);
                    return {
                        remaining: Math.max(0, tokens - usedTokens),
                        reset: (bucket + 1) * windowDuration
                    };
                },
                async resetTokens (ctx, identifier) {
                    const pattern = [
                        identifier,
                        "*"
                    ].join(":");
                    if (ctx.cache) {
                        ctx.cache.pop(identifier);
                    }
                    await safeEval(ctx, RESET_SCRIPT, [
                        pattern
                    ], [
                        null
                    ]);
                }
            });
    }
    /**
   * Combined approach of `slidingLogs` and `fixedWindow` with lower storage
   * costs than `slidingLogs` and improved boundary behavior by calculating a
   * weighted score between two windows.
   *
   * **Pro:**
   *
   * Good performance allows this to scale to very high loads.
   *
   * **Con:**
   *
   * Nothing major.
   *
   * @param tokens - How many requests a user can make in each time window.
   * @param window - The duration in which the user can max X requests.
   */ static slidingWindow(tokens, window) {
        const windowSize = ms(window);
        return ()=>({
                async limit (ctx, identifier, rate) {
                    const now = Date.now();
                    const currentWindow = Math.floor(now / windowSize);
                    const currentKey = [
                        identifier,
                        currentWindow
                    ].join(":");
                    const previousWindow = currentWindow - 1;
                    const previousKey = [
                        identifier,
                        previousWindow
                    ].join(":");
                    const incrementBy = rate ?? 1;
                    if (ctx.cache && incrementBy > 0) {
                        const { blocked, reset: reset2 } = ctx.cache.isBlocked(identifier);
                        if (blocked) {
                            return {
                                success: false,
                                limit: tokens,
                                remaining: 0,
                                reset: reset2,
                                pending: Promise.resolve(),
                                reason: "cacheBlock"
                            };
                        }
                    }
                    const remainingTokens = await safeEval(ctx, SCRIPTS.singleRegion.slidingWindow.limit, [
                        currentKey,
                        previousKey
                    ], [
                        tokens,
                        now,
                        windowSize,
                        incrementBy
                    ]);
                    const success = remainingTokens >= 0;
                    const reset = (currentWindow + 1) * windowSize;
                    if (ctx.cache) {
                        if (!success) {
                            ctx.cache.blockUntil(identifier, reset);
                        } else if (incrementBy < 0) {
                            ctx.cache.pop(identifier);
                        }
                    }
                    return {
                        success,
                        limit: tokens,
                        remaining: Math.max(0, remainingTokens),
                        reset,
                        pending: Promise.resolve()
                    };
                },
                async getRemaining (ctx, identifier) {
                    const now = Date.now();
                    const currentWindow = Math.floor(now / windowSize);
                    const currentKey = [
                        identifier,
                        currentWindow
                    ].join(":");
                    const previousWindow = currentWindow - 1;
                    const previousKey = [
                        identifier,
                        previousWindow
                    ].join(":");
                    const usedTokens = await safeEval(ctx, SCRIPTS.singleRegion.slidingWindow.getRemaining, [
                        currentKey,
                        previousKey
                    ], [
                        now,
                        windowSize
                    ]);
                    return {
                        remaining: Math.max(0, tokens - usedTokens),
                        reset: (currentWindow + 1) * windowSize
                    };
                },
                async resetTokens (ctx, identifier) {
                    const pattern = [
                        identifier,
                        "*"
                    ].join(":");
                    if (ctx.cache) {
                        ctx.cache.pop(identifier);
                    }
                    await safeEval(ctx, RESET_SCRIPT, [
                        pattern
                    ], [
                        null
                    ]);
                }
            });
    }
    /**
   * You have a bucket filled with `{maxTokens}` tokens that refills constantly
   * at `{refillRate}` per `{interval}`.
   * Every request will remove one token from the bucket and if there is no
   * token to take, the request is rejected.
   *
   * **Pro:**
   *
   * - Bursts of requests are smoothed out and you can process them at a constant
   * rate.
   * - Allows to set a higher initial burst limit by setting `maxTokens` higher
   * than `refillRate`
   */ static tokenBucket(refillRate, interval, maxTokens) {
        const intervalDuration = ms(interval);
        return ()=>({
                async limit (ctx, identifier, rate) {
                    const now = Date.now();
                    const incrementBy = rate ?? 1;
                    if (ctx.cache && incrementBy > 0) {
                        const { blocked, reset: reset2 } = ctx.cache.isBlocked(identifier);
                        if (blocked) {
                            return {
                                success: false,
                                limit: maxTokens,
                                remaining: 0,
                                reset: reset2,
                                pending: Promise.resolve(),
                                reason: "cacheBlock"
                            };
                        }
                    }
                    const [remaining, reset] = await safeEval(ctx, SCRIPTS.singleRegion.tokenBucket.limit, [
                        identifier
                    ], [
                        maxTokens,
                        intervalDuration,
                        refillRate,
                        now,
                        incrementBy
                    ]);
                    const success = remaining >= 0;
                    if (ctx.cache) {
                        if (!success) {
                            ctx.cache.blockUntil(identifier, reset);
                        } else if (incrementBy < 0) {
                            ctx.cache.pop(identifier);
                        }
                    }
                    return {
                        success,
                        limit: maxTokens,
                        remaining,
                        reset,
                        pending: Promise.resolve()
                    };
                },
                async getRemaining (ctx, identifier) {
                    const [remainingTokens, refilledAt] = await safeEval(ctx, SCRIPTS.singleRegion.tokenBucket.getRemaining, [
                        identifier
                    ], [
                        maxTokens
                    ]);
                    const freshRefillAt = Date.now() + intervalDuration;
                    const identifierRefillsAt = refilledAt + intervalDuration;
                    return {
                        remaining: remainingTokens,
                        reset: refilledAt === tokenBucketIdentifierNotFound ? freshRefillAt : identifierRefillsAt
                    };
                },
                async resetTokens (ctx, identifier) {
                    const pattern = identifier;
                    if (ctx.cache) {
                        ctx.cache.pop(identifier);
                    }
                    await safeEval(ctx, RESET_SCRIPT, [
                        pattern
                    ], [
                        null
                    ]);
                }
            });
    }
    /**
   * cachedFixedWindow first uses the local cache to decide if a request may pass and then updates
   * it asynchronously.
   * This is experimental and not yet recommended for production use.
   *
   * @experimental
   *
   * Each request inside a fixed time increases a counter.
   * Once the counter reaches the maximum allowed number, all further requests are
   * rejected.
   *
   * **Pro:**
   *
   * - Newer requests are not starved by old ones.
   * - Low storage cost.
   *
   * **Con:**
   *
   * A burst of requests near the boundary of a window can result in a very
   * high request rate because two windows will be filled with requests quickly.
   *
   * @param tokens - How many requests a user can make in each time window.
   * @param window - A fixed timeframe
   */ static cachedFixedWindow(tokens, window) {
        const windowDuration = ms(window);
        return ()=>({
                async limit (ctx, identifier, rate) {
                    if (!ctx.cache) {
                        throw new Error("This algorithm requires a cache");
                    }
                    const bucket = Math.floor(Date.now() / windowDuration);
                    const key = [
                        identifier,
                        bucket
                    ].join(":");
                    const reset = (bucket + 1) * windowDuration;
                    const incrementBy = rate ?? 1;
                    const hit = typeof ctx.cache.get(key) === "number";
                    if (hit) {
                        const cachedTokensAfterUpdate = ctx.cache.incr(key, incrementBy);
                        const success = cachedTokensAfterUpdate < tokens;
                        const pending = success ? safeEval(ctx, SCRIPTS.singleRegion.cachedFixedWindow.limit, [
                            key
                        ], [
                            windowDuration,
                            incrementBy
                        ]) : Promise.resolve();
                        return {
                            success,
                            limit: tokens,
                            remaining: tokens - cachedTokensAfterUpdate,
                            reset,
                            pending
                        };
                    }
                    const usedTokensAfterUpdate = await safeEval(ctx, SCRIPTS.singleRegion.cachedFixedWindow.limit, [
                        key
                    ], [
                        windowDuration,
                        incrementBy
                    ]);
                    ctx.cache.set(key, usedTokensAfterUpdate);
                    const remaining = tokens - usedTokensAfterUpdate;
                    return {
                        success: remaining >= 0,
                        limit: tokens,
                        remaining,
                        reset,
                        pending: Promise.resolve()
                    };
                },
                async getRemaining (ctx, identifier) {
                    if (!ctx.cache) {
                        throw new Error("This algorithm requires a cache");
                    }
                    const bucket = Math.floor(Date.now() / windowDuration);
                    const key = [
                        identifier,
                        bucket
                    ].join(":");
                    const hit = typeof ctx.cache.get(key) === "number";
                    if (hit) {
                        const cachedUsedTokens = ctx.cache.get(key) ?? 0;
                        return {
                            remaining: Math.max(0, tokens - cachedUsedTokens),
                            reset: (bucket + 1) * windowDuration
                        };
                    }
                    const usedTokens = await safeEval(ctx, SCRIPTS.singleRegion.cachedFixedWindow.getRemaining, [
                        key
                    ], [
                        null
                    ]);
                    return {
                        remaining: Math.max(0, tokens - usedTokens),
                        reset: (bucket + 1) * windowDuration
                    };
                },
                async resetTokens (ctx, identifier) {
                    if (!ctx.cache) {
                        throw new Error("This algorithm requires a cache");
                    }
                    const bucket = Math.floor(Date.now() / windowDuration);
                    const key = [
                        identifier,
                        bucket
                    ].join(":");
                    ctx.cache.pop(key);
                    const pattern = [
                        identifier,
                        "*"
                    ].join(":");
                    await safeEval(ctx, RESET_SCRIPT, [
                        pattern
                    ], [
                        null
                    ]);
                }
            });
    }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    Analytics,
    IpDenyList,
    MultiRegionRatelimit,
    Ratelimit
}); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/uncrypto/dist/crypto.node.mjs [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>_crypto,
    "getRandomValues",
    ()=>getRandomValues,
    "randomUUID",
    ()=>randomUUID,
    "subtle",
    ()=>subtle
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:crypto [external] (node:crypto, cjs)");
;
const subtle = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["default"].webcrypto?.subtle || {};
const randomUUID = ()=>{
    return __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["default"].randomUUID();
};
const getRandomValues = (array)=>{
    return __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["default"].webcrypto.getRandomValues(array);
};
const _crypto = {
    randomUUID,
    getRandomValues,
    subtle
};
;
}),
"[project]/node_modules/@upstash/redis/chunk-TBGBPMGD.mjs [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "HttpClient",
    ()=>HttpClient,
    "Redis",
    ()=>Redis,
    "VERSION",
    ()=>VERSION,
    "error_exports",
    ()=>error_exports
]);
// pkg/script.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uncrypto$2f$dist$2f$crypto$2e$node$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uncrypto/dist/crypto.node.mjs [app-rsc] (ecmascript)");
var __defProp = Object.defineProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
// pkg/error.ts
var error_exports = {};
__export(error_exports, {
    UpstashError: ()=>UpstashError,
    UpstashJSONParseError: ()=>UpstashJSONParseError,
    UrlError: ()=>UrlError
});
var UpstashError = class extends Error {
    constructor(message, options){
        super(message, options);
        this.name = "UpstashError";
    }
};
var UrlError = class extends Error {
    constructor(url){
        super(`Upstash Redis client was passed an invalid URL. You should pass a URL starting with https. Received: "${url}". `);
        this.name = "UrlError";
    }
};
var UpstashJSONParseError = class extends UpstashError {
    constructor(body, options){
        const truncatedBody = body.length > 200 ? body.slice(0, 200) + "..." : body;
        super(`Unable to parse response body: ${truncatedBody}`, options);
        this.name = "UpstashJSONParseError";
    }
};
// pkg/util.ts
function parseRecursive(obj) {
    const parsed = Array.isArray(obj) ? obj.map((o)=>{
        try {
            return parseRecursive(o);
        } catch  {
            return o;
        }
    }) : JSON.parse(obj);
    if (typeof parsed === "number" && parsed.toString() !== obj) {
        return obj;
    }
    return parsed;
}
function parseResponse(result) {
    try {
        return parseRecursive(result);
    } catch  {
        return result;
    }
}
function deserializeScanResponse(result) {
    return [
        result[0],
        ...parseResponse(result.slice(1))
    ];
}
function deserializeScanWithTypesResponse(result) {
    const [cursor, keys] = result;
    const parsedKeys = [];
    for(let i = 0; i < keys.length; i += 2){
        parsedKeys.push({
            key: keys[i],
            type: keys[i + 1]
        });
    }
    return [
        cursor,
        parsedKeys
    ];
}
function mergeHeaders(...headers) {
    const merged = {};
    for (const header of headers){
        if (!header) continue;
        for (const [key, value] of Object.entries(header)){
            if (value !== void 0 && value !== null) {
                merged[key] = value;
            }
        }
    }
    return merged;
}
// pkg/http.ts
var HttpClient = class {
    baseUrl;
    headers;
    options;
    readYourWrites;
    upstashSyncToken = "";
    hasCredentials;
    retry;
    constructor(config){
        this.options = {
            backend: config.options?.backend,
            agent: config.agent,
            responseEncoding: config.responseEncoding ?? "base64",
            // default to base64
            cache: config.cache,
            signal: config.signal,
            keepAlive: config.keepAlive ?? true
        };
        this.upstashSyncToken = "";
        this.readYourWrites = config.readYourWrites ?? true;
        this.baseUrl = (config.baseUrl || "").replace(/\/$/, "");
        const urlRegex = /^https?:\/\/[^\s#$./?].\S*$/;
        if (this.baseUrl && !urlRegex.test(this.baseUrl)) {
            throw new UrlError(this.baseUrl);
        }
        this.headers = {
            "Content-Type": "application/json",
            ...config.headers
        };
        this.hasCredentials = Boolean(this.baseUrl && this.headers.authorization.split(" ")[1]);
        if (this.options.responseEncoding === "base64") {
            this.headers["Upstash-Encoding"] = "base64";
        }
        this.retry = typeof config.retry === "boolean" && !config.retry ? {
            attempts: 1,
            backoff: ()=>0
        } : {
            attempts: config.retry?.retries ?? 5,
            backoff: config.retry?.backoff ?? ((retryCount)=>Math.exp(retryCount) * 50)
        };
    }
    mergeTelemetry(telemetry) {
        this.headers = merge(this.headers, "Upstash-Telemetry-Runtime", telemetry.runtime);
        this.headers = merge(this.headers, "Upstash-Telemetry-Platform", telemetry.platform);
        this.headers = merge(this.headers, "Upstash-Telemetry-Sdk", telemetry.sdk);
    }
    async request(req) {
        const requestHeaders = mergeHeaders(this.headers, req.headers ?? {});
        const requestUrl = [
            this.baseUrl,
            ...req.path ?? []
        ].join("/");
        const isEventStream = requestHeaders.Accept === "text/event-stream";
        const signal = req.signal ?? this.options.signal;
        const isSignalFunction = typeof signal === "function";
        const requestOptions = {
            //@ts-expect-error this should throw due to bun regression
            cache: this.options.cache,
            method: "POST",
            headers: requestHeaders,
            body: JSON.stringify(req.body),
            keepalive: this.options.keepAlive,
            agent: this.options.agent,
            signal: isSignalFunction ? signal() : signal,
            /**
       * Fastly specific
       */ backend: this.options.backend
        };
        if (!this.hasCredentials) {
            console.warn("[Upstash Redis] Redis client was initialized without url or token. Failed to execute command.");
        }
        if (this.readYourWrites) {
            const newHeader = this.upstashSyncToken;
            this.headers["upstash-sync-token"] = newHeader;
        }
        let res = null;
        let error = null;
        for(let i = 0; i <= this.retry.attempts; i++){
            try {
                res = await fetch(requestUrl, requestOptions);
                break;
            } catch (error_) {
                if (requestOptions.signal?.aborted && isSignalFunction) {
                    throw error_;
                } else if (requestOptions.signal?.aborted) {
                    const myBlob = new Blob([
                        JSON.stringify({
                            result: requestOptions.signal.reason ?? "Aborted"
                        })
                    ]);
                    const myOptions = {
                        status: 200,
                        statusText: requestOptions.signal.reason ?? "Aborted"
                    };
                    res = new Response(myBlob, myOptions);
                    break;
                }
                error = error_;
                if (i < this.retry.attempts) {
                    await new Promise((r)=>setTimeout(r, this.retry.backoff(i)));
                }
            }
        }
        if (!res) {
            throw error ?? new Error("Exhausted all retries");
        }
        if (!res.ok) {
            let body2;
            const rawBody2 = await res.text();
            try {
                body2 = JSON.parse(rawBody2);
            } catch (error2) {
                throw new UpstashJSONParseError(rawBody2, {
                    cause: error2
                });
            }
            throw new UpstashError(`${body2.error}, command was: ${JSON.stringify(req.body)}`);
        }
        if (this.readYourWrites) {
            const headers = res.headers;
            this.upstashSyncToken = headers.get("upstash-sync-token") ?? "";
        }
        if (isEventStream && req && req.onMessage && res.body) {
            const reader = res.body.getReader();
            const decoder = new TextDecoder();
            (async ()=>{
                try {
                    while(true){
                        const { value, done } = await reader.read();
                        if (done) break;
                        const chunk = decoder.decode(value);
                        const lines = chunk.split("\n");
                        for (const line of lines){
                            if (line.startsWith("data: ")) {
                                const data = line.slice(6);
                                req.onMessage?.(data);
                            }
                        }
                    }
                } catch (error2) {
                    if (error2 instanceof Error && error2.name === "AbortError") {} else {
                        console.error("Stream reading error:", error2);
                    }
                } finally{
                    try {
                        await reader.cancel();
                    } catch  {}
                }
            })();
            return {
                result: 1
            };
        }
        let body;
        const rawBody = await res.text();
        try {
            body = JSON.parse(rawBody);
        } catch (error2) {
            throw new UpstashJSONParseError(rawBody, {
                cause: error2
            });
        }
        if (this.readYourWrites) {
            const headers = res.headers;
            this.upstashSyncToken = headers.get("upstash-sync-token") ?? "";
        }
        if (this.options.responseEncoding === "base64") {
            if (Array.isArray(body)) {
                return body.map(({ result: result2, error: error2 })=>({
                        result: decode(result2),
                        error: error2
                    }));
            }
            const result = decode(body.result);
            return {
                result,
                error: body.error
            };
        }
        return body;
    }
};
function base64decode(b64) {
    let dec = "";
    try {
        const binString = atob(b64);
        const size = binString.length;
        const bytes = new Uint8Array(size);
        for(let i = 0; i < size; i++){
            bytes[i] = binString.charCodeAt(i);
        }
        dec = new TextDecoder().decode(bytes);
    } catch  {
        dec = b64;
    }
    return dec;
}
function decode(raw) {
    let result = void 0;
    switch(typeof raw){
        case "undefined":
            {
                return raw;
            }
        case "number":
            {
                result = raw;
                break;
            }
        case "object":
            {
                if (Array.isArray(raw)) {
                    result = raw.map((v)=>typeof v === "string" ? base64decode(v) : Array.isArray(v) ? v.map((element)=>decode(element)) : v);
                } else {
                    result = null;
                }
                break;
            }
        case "string":
            {
                result = raw === "OK" ? "OK" : base64decode(raw);
                break;
            }
        default:
            {
                break;
            }
    }
    return result;
}
function merge(obj, key, value) {
    if (!value) {
        return obj;
    }
    obj[key] = obj[key] ? [
        obj[key],
        value
    ].join(",") : value;
    return obj;
}
// pkg/commands/command.ts
var defaultSerializer = (c)=>{
    switch(typeof c){
        case "string":
        case "number":
        case "boolean":
            {
                return c;
            }
        default:
            {
                return JSON.stringify(c);
            }
    }
};
var Command = class {
    command;
    serialize;
    deserialize;
    headers;
    path;
    onMessage;
    isStreaming;
    signal;
    /**
   * Create a new command instance.
   *
   * You can define a custom `deserialize` function. By default we try to deserialize as json.
   */ constructor(command, opts){
        this.serialize = defaultSerializer;
        this.deserialize = opts?.automaticDeserialization === void 0 || opts.automaticDeserialization ? opts?.deserialize ?? parseResponse : (x)=>x;
        this.command = command.map((c)=>this.serialize(c));
        this.headers = opts?.headers;
        this.path = opts?.path;
        this.onMessage = opts?.streamOptions?.onMessage;
        this.isStreaming = opts?.streamOptions?.isStreaming ?? false;
        this.signal = opts?.streamOptions?.signal;
        if (opts?.latencyLogging) {
            const originalExec = this.exec.bind(this);
            this.exec = async (client)=>{
                const start = performance.now();
                const result = await originalExec(client);
                const end = performance.now();
                const loggerResult = (end - start).toFixed(2);
                console.log(`Latency for \x1B[38;2;19;185;39m${this.command[0].toString().toUpperCase()}\x1B[0m: \x1B[38;2;0;255;255m${loggerResult} ms\x1B[0m`);
                return result;
            };
        }
    }
    /**
   * Execute the command using a client.
   */ async exec(client) {
        const { result, error } = await client.request({
            body: this.command,
            path: this.path,
            upstashSyncToken: client.upstashSyncToken,
            headers: this.headers,
            onMessage: this.onMessage,
            isStreaming: this.isStreaming,
            signal: this.signal
        });
        if (error) {
            throw new UpstashError(error);
        }
        if (result === void 0) {
            throw new TypeError("Request did not return a result");
        }
        return this.deserialize(result);
    }
};
// pkg/commands/hrandfield.ts
function deserialize(result) {
    if (result.length === 0) {
        return null;
    }
    const obj = {};
    for(let i = 0; i < result.length; i += 2){
        const key = result[i];
        const value = result[i + 1];
        try {
            obj[key] = JSON.parse(value);
        } catch  {
            obj[key] = value;
        }
    }
    return obj;
}
var HRandFieldCommand = class extends Command {
    constructor(cmd, opts){
        const command = [
            "hrandfield",
            cmd[0]
        ];
        if (typeof cmd[1] === "number") {
            command.push(cmd[1]);
        }
        if (cmd[2]) {
            command.push("WITHVALUES");
        }
        super(command, {
            // @ts-expect-error to silence compiler
            deserialize: cmd[2] ? (result)=>deserialize(result) : opts?.deserialize,
            ...opts
        });
    }
};
// pkg/commands/append.ts
var AppendCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "append",
            ...cmd
        ], opts);
    }
};
// pkg/commands/bitcount.ts
var BitCountCommand = class extends Command {
    constructor([key, start, end], opts){
        const command = [
            "bitcount",
            key
        ];
        if (typeof start === "number") {
            command.push(start);
        }
        if (typeof end === "number") {
            command.push(end);
        }
        super(command, opts);
    }
};
// pkg/commands/bitfield.ts
var BitFieldCommand = class {
    constructor(args, client, opts, execOperation = (command)=>command.exec(this.client)){
        this.client = client;
        this.opts = opts;
        this.execOperation = execOperation;
        this.command = [
            "bitfield",
            ...args
        ];
    }
    command;
    chain(...args) {
        this.command.push(...args);
        return this;
    }
    get(...args) {
        return this.chain("get", ...args);
    }
    set(...args) {
        return this.chain("set", ...args);
    }
    incrby(...args) {
        return this.chain("incrby", ...args);
    }
    overflow(overflow) {
        return this.chain("overflow", overflow);
    }
    exec() {
        const command = new Command(this.command, this.opts);
        return this.execOperation(command);
    }
};
// pkg/commands/bitop.ts
var BitOpCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "bitop",
            ...cmd
        ], opts);
    }
};
// pkg/commands/bitpos.ts
var BitPosCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "bitpos",
            ...cmd
        ], opts);
    }
};
// pkg/commands/copy.ts
var CopyCommand = class extends Command {
    constructor([key, destinationKey, opts], commandOptions){
        super([
            "COPY",
            key,
            destinationKey,
            ...opts?.replace ? [
                "REPLACE"
            ] : []
        ], {
            ...commandOptions,
            deserialize (result) {
                if (result > 0) {
                    return "COPIED";
                }
                return "NOT_COPIED";
            }
        });
    }
};
// pkg/commands/dbsize.ts
var DBSizeCommand = class extends Command {
    constructor(opts){
        super([
            "dbsize"
        ], opts);
    }
};
// pkg/commands/decr.ts
var DecrCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "decr",
            ...cmd
        ], opts);
    }
};
// pkg/commands/decrby.ts
var DecrByCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "decrby",
            ...cmd
        ], opts);
    }
};
// pkg/commands/del.ts
var DelCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "del",
            ...cmd
        ], opts);
    }
};
// pkg/commands/echo.ts
var EchoCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "echo",
            ...cmd
        ], opts);
    }
};
// pkg/commands/evalRo.ts
var EvalROCommand = class extends Command {
    constructor([script, keys, args], opts){
        super([
            "eval_ro",
            script,
            keys.length,
            ...keys,
            ...args ?? []
        ], opts);
    }
};
// pkg/commands/eval.ts
var EvalCommand = class extends Command {
    constructor([script, keys, args], opts){
        super([
            "eval",
            script,
            keys.length,
            ...keys,
            ...args ?? []
        ], opts);
    }
};
// pkg/commands/evalshaRo.ts
var EvalshaROCommand = class extends Command {
    constructor([sha, keys, args], opts){
        super([
            "evalsha_ro",
            sha,
            keys.length,
            ...keys,
            ...args ?? []
        ], opts);
    }
};
// pkg/commands/evalsha.ts
var EvalshaCommand = class extends Command {
    constructor([sha, keys, args], opts){
        super([
            "evalsha",
            sha,
            keys.length,
            ...keys,
            ...args ?? []
        ], opts);
    }
};
// pkg/commands/exec.ts
var ExecCommand = class extends Command {
    constructor(cmd, opts){
        const normalizedCmd = cmd.map((arg)=>typeof arg === "string" ? arg : String(arg));
        super(normalizedCmd, opts);
    }
};
// pkg/commands/exists.ts
var ExistsCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "exists",
            ...cmd
        ], opts);
    }
};
// pkg/commands/expire.ts
var ExpireCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "expire",
            ...cmd.filter(Boolean)
        ], opts);
    }
};
// pkg/commands/expireat.ts
var ExpireAtCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "expireat",
            ...cmd
        ], opts);
    }
};
// pkg/commands/flushall.ts
var FlushAllCommand = class extends Command {
    constructor(args, opts){
        const command = [
            "flushall"
        ];
        if (args && args.length > 0 && args[0].async) {
            command.push("async");
        }
        super(command, opts);
    }
};
// pkg/commands/flushdb.ts
var FlushDBCommand = class extends Command {
    constructor([opts], cmdOpts){
        const command = [
            "flushdb"
        ];
        if (opts?.async) {
            command.push("async");
        }
        super(command, cmdOpts);
    }
};
// pkg/commands/geo_add.ts
var GeoAddCommand = class extends Command {
    constructor([key, arg1, ...arg2], opts){
        const command = [
            "geoadd",
            key
        ];
        if ("nx" in arg1 && arg1.nx) {
            command.push("nx");
        } else if ("xx" in arg1 && arg1.xx) {
            command.push("xx");
        }
        if ("ch" in arg1 && arg1.ch) {
            command.push("ch");
        }
        if ("latitude" in arg1 && arg1.latitude) {
            command.push(arg1.longitude, arg1.latitude, arg1.member);
        }
        command.push(...arg2.flatMap(({ latitude, longitude, member })=>[
                longitude,
                latitude,
                member
            ]));
        super(command, opts);
    }
};
// pkg/commands/geo_dist.ts
var GeoDistCommand = class extends Command {
    constructor([key, member1, member2, unit = "M"], opts){
        super([
            "GEODIST",
            key,
            member1,
            member2,
            unit
        ], opts);
    }
};
// pkg/commands/geo_hash.ts
var GeoHashCommand = class extends Command {
    constructor(cmd, opts){
        const [key] = cmd;
        const members = Array.isArray(cmd[1]) ? cmd[1] : cmd.slice(1);
        super([
            "GEOHASH",
            key,
            ...members
        ], opts);
    }
};
// pkg/commands/geo_pos.ts
var GeoPosCommand = class extends Command {
    constructor(cmd, opts){
        const [key] = cmd;
        const members = Array.isArray(cmd[1]) ? cmd[1] : cmd.slice(1);
        super([
            "GEOPOS",
            key,
            ...members
        ], {
            deserialize: (result)=>transform(result),
            ...opts
        });
    }
};
function transform(result) {
    const final = [];
    for (const pos of result){
        if (!pos?.[0] || !pos?.[1]) {
            continue;
        }
        final.push({
            lng: Number.parseFloat(pos[0]),
            lat: Number.parseFloat(pos[1])
        });
    }
    return final;
}
// pkg/commands/geo_search.ts
var GeoSearchCommand = class extends Command {
    constructor([key, centerPoint, shape, order, opts], commandOptions){
        const command = [
            "GEOSEARCH",
            key
        ];
        if (centerPoint.type === "FROMMEMBER" || centerPoint.type === "frommember") {
            command.push(centerPoint.type, centerPoint.member);
        }
        if (centerPoint.type === "FROMLONLAT" || centerPoint.type === "fromlonlat") {
            command.push(centerPoint.type, centerPoint.coordinate.lon, centerPoint.coordinate.lat);
        }
        if (shape.type === "BYRADIUS" || shape.type === "byradius") {
            command.push(shape.type, shape.radius, shape.radiusType);
        }
        if (shape.type === "BYBOX" || shape.type === "bybox") {
            command.push(shape.type, shape.rect.width, shape.rect.height, shape.rectType);
        }
        command.push(order);
        if (opts?.count) {
            command.push("COUNT", opts.count.limit, ...opts.count.any ? [
                "ANY"
            ] : []);
        }
        const transform2 = (result)=>{
            if (!opts?.withCoord && !opts?.withDist && !opts?.withHash) {
                return result.map((member)=>{
                    try {
                        return {
                            member: JSON.parse(member)
                        };
                    } catch  {
                        return {
                            member
                        };
                    }
                });
            }
            return result.map((members)=>{
                let counter = 1;
                const obj = {};
                try {
                    obj.member = JSON.parse(members[0]);
                } catch  {
                    obj.member = members[0];
                }
                if (opts.withDist) {
                    obj.dist = Number.parseFloat(members[counter++]);
                }
                if (opts.withHash) {
                    obj.hash = members[counter++].toString();
                }
                if (opts.withCoord) {
                    obj.coord = {
                        long: Number.parseFloat(members[counter][0]),
                        lat: Number.parseFloat(members[counter][1])
                    };
                }
                return obj;
            });
        };
        super([
            ...command,
            ...opts?.withCoord ? [
                "WITHCOORD"
            ] : [],
            ...opts?.withDist ? [
                "WITHDIST"
            ] : [],
            ...opts?.withHash ? [
                "WITHHASH"
            ] : []
        ], {
            deserialize: transform2,
            ...commandOptions
        });
    }
};
// pkg/commands/geo_search_store.ts
var GeoSearchStoreCommand = class extends Command {
    constructor([destination, key, centerPoint, shape, order, opts], commandOptions){
        const command = [
            "GEOSEARCHSTORE",
            destination,
            key
        ];
        if (centerPoint.type === "FROMMEMBER" || centerPoint.type === "frommember") {
            command.push(centerPoint.type, centerPoint.member);
        }
        if (centerPoint.type === "FROMLONLAT" || centerPoint.type === "fromlonlat") {
            command.push(centerPoint.type, centerPoint.coordinate.lon, centerPoint.coordinate.lat);
        }
        if (shape.type === "BYRADIUS" || shape.type === "byradius") {
            command.push(shape.type, shape.radius, shape.radiusType);
        }
        if (shape.type === "BYBOX" || shape.type === "bybox") {
            command.push(shape.type, shape.rect.width, shape.rect.height, shape.rectType);
        }
        command.push(order);
        if (opts?.count) {
            command.push("COUNT", opts.count.limit, ...opts.count.any ? [
                "ANY"
            ] : []);
        }
        super([
            ...command,
            ...opts?.storeDist ? [
                "STOREDIST"
            ] : []
        ], commandOptions);
    }
};
// pkg/commands/get.ts
var GetCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "get",
            ...cmd
        ], opts);
    }
};
// pkg/commands/getbit.ts
var GetBitCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "getbit",
            ...cmd
        ], opts);
    }
};
// pkg/commands/getdel.ts
var GetDelCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "getdel",
            ...cmd
        ], opts);
    }
};
// pkg/commands/getex.ts
var GetExCommand = class extends Command {
    constructor([key, opts], cmdOpts){
        const command = [
            "getex",
            key
        ];
        if (opts) {
            if ("ex" in opts && typeof opts.ex === "number") {
                command.push("ex", opts.ex);
            } else if ("px" in opts && typeof opts.px === "number") {
                command.push("px", opts.px);
            } else if ("exat" in opts && typeof opts.exat === "number") {
                command.push("exat", opts.exat);
            } else if ("pxat" in opts && typeof opts.pxat === "number") {
                command.push("pxat", opts.pxat);
            } else if ("persist" in opts && opts.persist) {
                command.push("persist");
            }
        }
        super(command, cmdOpts);
    }
};
// pkg/commands/getrange.ts
var GetRangeCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "getrange",
            ...cmd
        ], opts);
    }
};
// pkg/commands/getset.ts
var GetSetCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "getset",
            ...cmd
        ], opts);
    }
};
// pkg/commands/hdel.ts
var HDelCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "hdel",
            ...cmd
        ], opts);
    }
};
// pkg/commands/hexists.ts
var HExistsCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "hexists",
            ...cmd
        ], opts);
    }
};
// pkg/commands/hexpire.ts
var HExpireCommand = class extends Command {
    constructor(cmd, opts){
        const [key, fields, seconds, option] = cmd;
        const fieldArray = Array.isArray(fields) ? fields : [
            fields
        ];
        super([
            "hexpire",
            key,
            seconds,
            ...option ? [
                option
            ] : [],
            "FIELDS",
            fieldArray.length,
            ...fieldArray
        ], opts);
    }
};
// pkg/commands/hexpireat.ts
var HExpireAtCommand = class extends Command {
    constructor(cmd, opts){
        const [key, fields, timestamp, option] = cmd;
        const fieldArray = Array.isArray(fields) ? fields : [
            fields
        ];
        super([
            "hexpireat",
            key,
            timestamp,
            ...option ? [
                option
            ] : [],
            "FIELDS",
            fieldArray.length,
            ...fieldArray
        ], opts);
    }
};
// pkg/commands/hexpiretime.ts
var HExpireTimeCommand = class extends Command {
    constructor(cmd, opts){
        const [key, fields] = cmd;
        const fieldArray = Array.isArray(fields) ? fields : [
            fields
        ];
        super([
            "hexpiretime",
            key,
            "FIELDS",
            fieldArray.length,
            ...fieldArray
        ], opts);
    }
};
// pkg/commands/hpersist.ts
var HPersistCommand = class extends Command {
    constructor(cmd, opts){
        const [key, fields] = cmd;
        const fieldArray = Array.isArray(fields) ? fields : [
            fields
        ];
        super([
            "hpersist",
            key,
            "FIELDS",
            fieldArray.length,
            ...fieldArray
        ], opts);
    }
};
// pkg/commands/hpexpire.ts
var HPExpireCommand = class extends Command {
    constructor(cmd, opts){
        const [key, fields, milliseconds, option] = cmd;
        const fieldArray = Array.isArray(fields) ? fields : [
            fields
        ];
        super([
            "hpexpire",
            key,
            milliseconds,
            ...option ? [
                option
            ] : [],
            "FIELDS",
            fieldArray.length,
            ...fieldArray
        ], opts);
    }
};
// pkg/commands/hpexpireat.ts
var HPExpireAtCommand = class extends Command {
    constructor(cmd, opts){
        const [key, fields, timestamp, option] = cmd;
        const fieldArray = Array.isArray(fields) ? fields : [
            fields
        ];
        super([
            "hpexpireat",
            key,
            timestamp,
            ...option ? [
                option
            ] : [],
            "FIELDS",
            fieldArray.length,
            ...fieldArray
        ], opts);
    }
};
// pkg/commands/hpexpiretime.ts
var HPExpireTimeCommand = class extends Command {
    constructor(cmd, opts){
        const [key, fields] = cmd;
        const fieldArray = Array.isArray(fields) ? fields : [
            fields
        ];
        super([
            "hpexpiretime",
            key,
            "FIELDS",
            fieldArray.length,
            ...fieldArray
        ], opts);
    }
};
// pkg/commands/hpttl.ts
var HPTtlCommand = class extends Command {
    constructor(cmd, opts){
        const [key, fields] = cmd;
        const fieldArray = Array.isArray(fields) ? fields : [
            fields
        ];
        super([
            "hpttl",
            key,
            "FIELDS",
            fieldArray.length,
            ...fieldArray
        ], opts);
    }
};
// pkg/commands/hget.ts
var HGetCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "hget",
            ...cmd
        ], opts);
    }
};
// pkg/commands/hgetall.ts
function deserialize2(result) {
    if (result.length === 0) {
        return null;
    }
    const obj = {};
    for(let i = 0; i < result.length; i += 2){
        const key = result[i];
        const value = result[i + 1];
        try {
            const valueIsNumberAndNotSafeInteger = !Number.isNaN(Number(value)) && !Number.isSafeInteger(Number(value));
            obj[key] = valueIsNumberAndNotSafeInteger ? value : JSON.parse(value);
        } catch  {
            obj[key] = value;
        }
    }
    return obj;
}
var HGetAllCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "hgetall",
            ...cmd
        ], {
            deserialize: (result)=>deserialize2(result),
            ...opts
        });
    }
};
// pkg/commands/hincrby.ts
var HIncrByCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "hincrby",
            ...cmd
        ], opts);
    }
};
// pkg/commands/hincrbyfloat.ts
var HIncrByFloatCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "hincrbyfloat",
            ...cmd
        ], opts);
    }
};
// pkg/commands/hkeys.ts
var HKeysCommand = class extends Command {
    constructor([key], opts){
        super([
            "hkeys",
            key
        ], opts);
    }
};
// pkg/commands/hlen.ts
var HLenCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "hlen",
            ...cmd
        ], opts);
    }
};
// pkg/commands/hmget.ts
function deserialize3(fields, result) {
    if (result.every((field)=>field === null)) {
        return null;
    }
    const obj = {};
    for (const [i, field] of fields.entries()){
        try {
            obj[field] = JSON.parse(result[i]);
        } catch  {
            obj[field] = result[i];
        }
    }
    return obj;
}
var HMGetCommand = class extends Command {
    constructor([key, ...fields], opts){
        super([
            "hmget",
            key,
            ...fields
        ], {
            deserialize: (result)=>deserialize3(fields, result),
            ...opts
        });
    }
};
// pkg/commands/hmset.ts
var HMSetCommand = class extends Command {
    constructor([key, kv], opts){
        super([
            "hmset",
            key,
            ...Object.entries(kv).flatMap(([field, value])=>[
                    field,
                    value
                ])
        ], opts);
    }
};
// pkg/commands/hscan.ts
var HScanCommand = class extends Command {
    constructor([key, cursor, cmdOpts], opts){
        const command = [
            "hscan",
            key,
            cursor
        ];
        if (cmdOpts?.match) {
            command.push("match", cmdOpts.match);
        }
        if (typeof cmdOpts?.count === "number") {
            command.push("count", cmdOpts.count);
        }
        super(command, {
            deserialize: deserializeScanResponse,
            ...opts
        });
    }
};
// pkg/commands/hset.ts
var HSetCommand = class extends Command {
    constructor([key, kv], opts){
        super([
            "hset",
            key,
            ...Object.entries(kv).flatMap(([field, value])=>[
                    field,
                    value
                ])
        ], opts);
    }
};
// pkg/commands/hsetnx.ts
var HSetNXCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "hsetnx",
            ...cmd
        ], opts);
    }
};
// pkg/commands/hstrlen.ts
var HStrLenCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "hstrlen",
            ...cmd
        ], opts);
    }
};
// pkg/commands/httl.ts
var HTtlCommand = class extends Command {
    constructor(cmd, opts){
        const [key, fields] = cmd;
        const fieldArray = Array.isArray(fields) ? fields : [
            fields
        ];
        super([
            "httl",
            key,
            "FIELDS",
            fieldArray.length,
            ...fieldArray
        ], opts);
    }
};
// pkg/commands/hvals.ts
var HValsCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "hvals",
            ...cmd
        ], opts);
    }
};
// pkg/commands/incr.ts
var IncrCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "incr",
            ...cmd
        ], opts);
    }
};
// pkg/commands/incrby.ts
var IncrByCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "incrby",
            ...cmd
        ], opts);
    }
};
// pkg/commands/incrbyfloat.ts
var IncrByFloatCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "incrbyfloat",
            ...cmd
        ], opts);
    }
};
// pkg/commands/json_arrappend.ts
var JsonArrAppendCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "JSON.ARRAPPEND",
            ...cmd
        ], opts);
    }
};
// pkg/commands/json_arrindex.ts
var JsonArrIndexCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "JSON.ARRINDEX",
            ...cmd
        ], opts);
    }
};
// pkg/commands/json_arrinsert.ts
var JsonArrInsertCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "JSON.ARRINSERT",
            ...cmd
        ], opts);
    }
};
// pkg/commands/json_arrlen.ts
var JsonArrLenCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "JSON.ARRLEN",
            cmd[0],
            cmd[1] ?? "$"
        ], opts);
    }
};
// pkg/commands/json_arrpop.ts
var JsonArrPopCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "JSON.ARRPOP",
            ...cmd
        ], opts);
    }
};
// pkg/commands/json_arrtrim.ts
var JsonArrTrimCommand = class extends Command {
    constructor(cmd, opts){
        const path = cmd[1] ?? "$";
        const start = cmd[2] ?? 0;
        const stop = cmd[3] ?? 0;
        super([
            "JSON.ARRTRIM",
            cmd[0],
            path,
            start,
            stop
        ], opts);
    }
};
// pkg/commands/json_clear.ts
var JsonClearCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "JSON.CLEAR",
            ...cmd
        ], opts);
    }
};
// pkg/commands/json_del.ts
var JsonDelCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "JSON.DEL",
            ...cmd
        ], opts);
    }
};
// pkg/commands/json_forget.ts
var JsonForgetCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "JSON.FORGET",
            ...cmd
        ], opts);
    }
};
// pkg/commands/json_get.ts
var JsonGetCommand = class extends Command {
    constructor(cmd, opts){
        const command = [
            "JSON.GET"
        ];
        if (typeof cmd[1] === "string") {
            command.push(...cmd);
        } else {
            command.push(cmd[0]);
            if (cmd[1]) {
                if (cmd[1].indent) {
                    command.push("INDENT", cmd[1].indent);
                }
                if (cmd[1].newline) {
                    command.push("NEWLINE", cmd[1].newline);
                }
                if (cmd[1].space) {
                    command.push("SPACE", cmd[1].space);
                }
            }
            command.push(...cmd.slice(2));
        }
        super(command, opts);
    }
};
// pkg/commands/json_merge.ts
var JsonMergeCommand = class extends Command {
    constructor(cmd, opts){
        const command = [
            "JSON.MERGE",
            ...cmd
        ];
        super(command, opts);
    }
};
// pkg/commands/json_mget.ts
var JsonMGetCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "JSON.MGET",
            ...cmd[0],
            cmd[1]
        ], opts);
    }
};
// pkg/commands/json_mset.ts
var JsonMSetCommand = class extends Command {
    constructor(cmd, opts){
        const command = [
            "JSON.MSET"
        ];
        for (const c of cmd){
            command.push(c.key, c.path, c.value);
        }
        super(command, opts);
    }
};
// pkg/commands/json_numincrby.ts
var JsonNumIncrByCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "JSON.NUMINCRBY",
            ...cmd
        ], opts);
    }
};
// pkg/commands/json_nummultby.ts
var JsonNumMultByCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "JSON.NUMMULTBY",
            ...cmd
        ], opts);
    }
};
// pkg/commands/json_objkeys.ts
var JsonObjKeysCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "JSON.OBJKEYS",
            ...cmd
        ], opts);
    }
};
// pkg/commands/json_objlen.ts
var JsonObjLenCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "JSON.OBJLEN",
            ...cmd
        ], opts);
    }
};
// pkg/commands/json_resp.ts
var JsonRespCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "JSON.RESP",
            ...cmd
        ], opts);
    }
};
// pkg/commands/json_set.ts
var JsonSetCommand = class extends Command {
    constructor(cmd, opts){
        const command = [
            "JSON.SET",
            cmd[0],
            cmd[1],
            cmd[2]
        ];
        if (cmd[3]) {
            if (cmd[3].nx) {
                command.push("NX");
            } else if (cmd[3].xx) {
                command.push("XX");
            }
        }
        super(command, opts);
    }
};
// pkg/commands/json_strappend.ts
var JsonStrAppendCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "JSON.STRAPPEND",
            ...cmd
        ], opts);
    }
};
// pkg/commands/json_strlen.ts
var JsonStrLenCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "JSON.STRLEN",
            ...cmd
        ], opts);
    }
};
// pkg/commands/json_toggle.ts
var JsonToggleCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "JSON.TOGGLE",
            ...cmd
        ], opts);
    }
};
// pkg/commands/json_type.ts
var JsonTypeCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "JSON.TYPE",
            ...cmd
        ], opts);
    }
};
// pkg/commands/keys.ts
var KeysCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "keys",
            ...cmd
        ], opts);
    }
};
// pkg/commands/lindex.ts
var LIndexCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "lindex",
            ...cmd
        ], opts);
    }
};
// pkg/commands/linsert.ts
var LInsertCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "linsert",
            ...cmd
        ], opts);
    }
};
// pkg/commands/llen.ts
var LLenCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "llen",
            ...cmd
        ], opts);
    }
};
// pkg/commands/lmove.ts
var LMoveCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "lmove",
            ...cmd
        ], opts);
    }
};
// pkg/commands/lmpop.ts
var LmPopCommand = class extends Command {
    constructor(cmd, opts){
        const [numkeys, keys, direction, count] = cmd;
        super([
            "LMPOP",
            numkeys,
            ...keys,
            direction,
            ...count ? [
                "COUNT",
                count
            ] : []
        ], opts);
    }
};
// pkg/commands/lpop.ts
var LPopCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "lpop",
            ...cmd
        ], opts);
    }
};
// pkg/commands/lpos.ts
var LPosCommand = class extends Command {
    constructor(cmd, opts){
        const args = [
            "lpos",
            cmd[0],
            cmd[1]
        ];
        if (typeof cmd[2]?.rank === "number") {
            args.push("rank", cmd[2].rank);
        }
        if (typeof cmd[2]?.count === "number") {
            args.push("count", cmd[2].count);
        }
        if (typeof cmd[2]?.maxLen === "number") {
            args.push("maxLen", cmd[2].maxLen);
        }
        super(args, opts);
    }
};
// pkg/commands/lpush.ts
var LPushCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "lpush",
            ...cmd
        ], opts);
    }
};
// pkg/commands/lpushx.ts
var LPushXCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "lpushx",
            ...cmd
        ], opts);
    }
};
// pkg/commands/lrange.ts
var LRangeCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "lrange",
            ...cmd
        ], opts);
    }
};
// pkg/commands/lrem.ts
var LRemCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "lrem",
            ...cmd
        ], opts);
    }
};
// pkg/commands/lset.ts
var LSetCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "lset",
            ...cmd
        ], opts);
    }
};
// pkg/commands/ltrim.ts
var LTrimCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "ltrim",
            ...cmd
        ], opts);
    }
};
// pkg/commands/mget.ts
var MGetCommand = class extends Command {
    constructor(cmd, opts){
        const keys = Array.isArray(cmd[0]) ? cmd[0] : cmd;
        super([
            "mget",
            ...keys
        ], opts);
    }
};
// pkg/commands/mset.ts
var MSetCommand = class extends Command {
    constructor([kv], opts){
        super([
            "mset",
            ...Object.entries(kv).flatMap(([key, value])=>[
                    key,
                    value
                ])
        ], opts);
    }
};
// pkg/commands/msetnx.ts
var MSetNXCommand = class extends Command {
    constructor([kv], opts){
        super([
            "msetnx",
            ...Object.entries(kv).flat()
        ], opts);
    }
};
// pkg/commands/persist.ts
var PersistCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "persist",
            ...cmd
        ], opts);
    }
};
// pkg/commands/pexpire.ts
var PExpireCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "pexpire",
            ...cmd
        ], opts);
    }
};
// pkg/commands/pexpireat.ts
var PExpireAtCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "pexpireat",
            ...cmd
        ], opts);
    }
};
// pkg/commands/pfadd.ts
var PfAddCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "pfadd",
            ...cmd
        ], opts);
    }
};
// pkg/commands/pfcount.ts
var PfCountCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "pfcount",
            ...cmd
        ], opts);
    }
};
// pkg/commands/pfmerge.ts
var PfMergeCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "pfmerge",
            ...cmd
        ], opts);
    }
};
// pkg/commands/ping.ts
var PingCommand = class extends Command {
    constructor(cmd, opts){
        const command = [
            "ping"
        ];
        if (cmd?.[0] !== void 0) {
            command.push(cmd[0]);
        }
        super(command, opts);
    }
};
// pkg/commands/psetex.ts
var PSetEXCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "psetex",
            ...cmd
        ], opts);
    }
};
// pkg/commands/pttl.ts
var PTtlCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "pttl",
            ...cmd
        ], opts);
    }
};
// pkg/commands/publish.ts
var PublishCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "publish",
            ...cmd
        ], opts);
    }
};
// pkg/commands/randomkey.ts
var RandomKeyCommand = class extends Command {
    constructor(opts){
        super([
            "randomkey"
        ], opts);
    }
};
// pkg/commands/rename.ts
var RenameCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "rename",
            ...cmd
        ], opts);
    }
};
// pkg/commands/renamenx.ts
var RenameNXCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "renamenx",
            ...cmd
        ], opts);
    }
};
// pkg/commands/rpop.ts
var RPopCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "rpop",
            ...cmd
        ], opts);
    }
};
// pkg/commands/rpush.ts
var RPushCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "rpush",
            ...cmd
        ], opts);
    }
};
// pkg/commands/rpushx.ts
var RPushXCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "rpushx",
            ...cmd
        ], opts);
    }
};
// pkg/commands/sadd.ts
var SAddCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "sadd",
            ...cmd
        ], opts);
    }
};
// pkg/commands/scan.ts
var ScanCommand = class extends Command {
    constructor([cursor, opts], cmdOpts){
        const command = [
            "scan",
            cursor
        ];
        if (opts?.match) {
            command.push("match", opts.match);
        }
        if (typeof opts?.count === "number") {
            command.push("count", opts.count);
        }
        if (opts && "withType" in opts && opts.withType === true) {
            command.push("withtype");
        } else if (opts && "type" in opts && opts.type && opts.type.length > 0) {
            command.push("type", opts.type);
        }
        super(command, {
            // @ts-expect-error ignore types here
            deserialize: opts?.withType ? deserializeScanWithTypesResponse : deserializeScanResponse,
            ...cmdOpts
        });
    }
};
// pkg/commands/scard.ts
var SCardCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "scard",
            ...cmd
        ], opts);
    }
};
// pkg/commands/script_exists.ts
var ScriptExistsCommand = class extends Command {
    constructor(hashes, opts){
        super([
            "script",
            "exists",
            ...hashes
        ], {
            deserialize: (result)=>result,
            ...opts
        });
    }
};
// pkg/commands/script_flush.ts
var ScriptFlushCommand = class extends Command {
    constructor([opts], cmdOpts){
        const cmd = [
            "script",
            "flush"
        ];
        if (opts?.sync) {
            cmd.push("sync");
        } else if (opts?.async) {
            cmd.push("async");
        }
        super(cmd, cmdOpts);
    }
};
// pkg/commands/script_load.ts
var ScriptLoadCommand = class extends Command {
    constructor(args, opts){
        super([
            "script",
            "load",
            ...args
        ], opts);
    }
};
// pkg/commands/sdiff.ts
var SDiffCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "sdiff",
            ...cmd
        ], opts);
    }
};
// pkg/commands/sdiffstore.ts
var SDiffStoreCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "sdiffstore",
            ...cmd
        ], opts);
    }
};
// pkg/commands/set.ts
var SetCommand = class extends Command {
    constructor([key, value, opts], cmdOpts){
        const command = [
            "set",
            key,
            value
        ];
        if (opts) {
            if ("nx" in opts && opts.nx) {
                command.push("nx");
            } else if ("xx" in opts && opts.xx) {
                command.push("xx");
            }
            if ("get" in opts && opts.get) {
                command.push("get");
            }
            if ("ex" in opts && typeof opts.ex === "number") {
                command.push("ex", opts.ex);
            } else if ("px" in opts && typeof opts.px === "number") {
                command.push("px", opts.px);
            } else if ("exat" in opts && typeof opts.exat === "number") {
                command.push("exat", opts.exat);
            } else if ("pxat" in opts && typeof opts.pxat === "number") {
                command.push("pxat", opts.pxat);
            } else if ("keepTtl" in opts && opts.keepTtl) {
                command.push("keepTtl");
            }
        }
        super(command, cmdOpts);
    }
};
// pkg/commands/setbit.ts
var SetBitCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "setbit",
            ...cmd
        ], opts);
    }
};
// pkg/commands/setex.ts
var SetExCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "setex",
            ...cmd
        ], opts);
    }
};
// pkg/commands/setnx.ts
var SetNxCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "setnx",
            ...cmd
        ], opts);
    }
};
// pkg/commands/setrange.ts
var SetRangeCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "setrange",
            ...cmd
        ], opts);
    }
};
// pkg/commands/sinter.ts
var SInterCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "sinter",
            ...cmd
        ], opts);
    }
};
// pkg/commands/sinterstore.ts
var SInterStoreCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "sinterstore",
            ...cmd
        ], opts);
    }
};
// pkg/commands/sismember.ts
var SIsMemberCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "sismember",
            ...cmd
        ], opts);
    }
};
// pkg/commands/smembers.ts
var SMembersCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "smembers",
            ...cmd
        ], opts);
    }
};
// pkg/commands/smismember.ts
var SMIsMemberCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "smismember",
            cmd[0],
            ...cmd[1]
        ], opts);
    }
};
// pkg/commands/smove.ts
var SMoveCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "smove",
            ...cmd
        ], opts);
    }
};
// pkg/commands/spop.ts
var SPopCommand = class extends Command {
    constructor([key, count], opts){
        const command = [
            "spop",
            key
        ];
        if (typeof count === "number") {
            command.push(count);
        }
        super(command, opts);
    }
};
// pkg/commands/srandmember.ts
var SRandMemberCommand = class extends Command {
    constructor([key, count], opts){
        const command = [
            "srandmember",
            key
        ];
        if (typeof count === "number") {
            command.push(count);
        }
        super(command, opts);
    }
};
// pkg/commands/srem.ts
var SRemCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "srem",
            ...cmd
        ], opts);
    }
};
// pkg/commands/sscan.ts
var SScanCommand = class extends Command {
    constructor([key, cursor, opts], cmdOpts){
        const command = [
            "sscan",
            key,
            cursor
        ];
        if (opts?.match) {
            command.push("match", opts.match);
        }
        if (typeof opts?.count === "number") {
            command.push("count", opts.count);
        }
        super(command, {
            deserialize: deserializeScanResponse,
            ...cmdOpts
        });
    }
};
// pkg/commands/strlen.ts
var StrLenCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "strlen",
            ...cmd
        ], opts);
    }
};
// pkg/commands/sunion.ts
var SUnionCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "sunion",
            ...cmd
        ], opts);
    }
};
// pkg/commands/sunionstore.ts
var SUnionStoreCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "sunionstore",
            ...cmd
        ], opts);
    }
};
// pkg/commands/time.ts
var TimeCommand = class extends Command {
    constructor(opts){
        super([
            "time"
        ], opts);
    }
};
// pkg/commands/touch.ts
var TouchCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "touch",
            ...cmd
        ], opts);
    }
};
// pkg/commands/ttl.ts
var TtlCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "ttl",
            ...cmd
        ], opts);
    }
};
// pkg/commands/type.ts
var TypeCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "type",
            ...cmd
        ], opts);
    }
};
// pkg/commands/unlink.ts
var UnlinkCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "unlink",
            ...cmd
        ], opts);
    }
};
// pkg/commands/xack.ts
var XAckCommand = class extends Command {
    constructor([key, group, id], opts){
        const ids = Array.isArray(id) ? [
            ...id
        ] : [
            id
        ];
        super([
            "XACK",
            key,
            group,
            ...ids
        ], opts);
    }
};
// pkg/commands/xadd.ts
var XAddCommand = class extends Command {
    constructor([key, id, entries, opts], commandOptions){
        const command = [
            "XADD",
            key
        ];
        if (opts) {
            if (opts.nomkStream) {
                command.push("NOMKSTREAM");
            }
            if (opts.trim) {
                command.push(opts.trim.type, opts.trim.comparison, opts.trim.threshold);
                if (opts.trim.limit !== void 0) {
                    command.push("LIMIT", opts.trim.limit);
                }
            }
        }
        command.push(id);
        for (const [k, v] of Object.entries(entries)){
            command.push(k, v);
        }
        super(command, commandOptions);
    }
};
// pkg/commands/xautoclaim.ts
var XAutoClaim = class extends Command {
    constructor([key, group, consumer, minIdleTime, start, options], opts){
        const commands = [];
        if (options?.count) {
            commands.push("COUNT", options.count);
        }
        if (options?.justId) {
            commands.push("JUSTID");
        }
        super([
            "XAUTOCLAIM",
            key,
            group,
            consumer,
            minIdleTime,
            start,
            ...commands
        ], opts);
    }
};
// pkg/commands/xclaim.ts
var XClaimCommand = class extends Command {
    constructor([key, group, consumer, minIdleTime, id, options], opts){
        const ids = Array.isArray(id) ? [
            ...id
        ] : [
            id
        ];
        const commands = [];
        if (options?.idleMS) {
            commands.push("IDLE", options.idleMS);
        }
        if (options?.idleMS) {
            commands.push("TIME", options.timeMS);
        }
        if (options?.retryCount) {
            commands.push("RETRYCOUNT", options.retryCount);
        }
        if (options?.force) {
            commands.push("FORCE");
        }
        if (options?.justId) {
            commands.push("JUSTID");
        }
        if (options?.lastId) {
            commands.push("LASTID", options.lastId);
        }
        super([
            "XCLAIM",
            key,
            group,
            consumer,
            minIdleTime,
            ...ids,
            ...commands
        ], opts);
    }
};
// pkg/commands/xdel.ts
var XDelCommand = class extends Command {
    constructor([key, ids], opts){
        const cmds = Array.isArray(ids) ? [
            ...ids
        ] : [
            ids
        ];
        super([
            "XDEL",
            key,
            ...cmds
        ], opts);
    }
};
// pkg/commands/xgroup.ts
var XGroupCommand = class extends Command {
    constructor([key, opts], commandOptions){
        const command = [
            "XGROUP"
        ];
        switch(opts.type){
            case "CREATE":
                {
                    command.push("CREATE", key, opts.group, opts.id);
                    if (opts.options) {
                        if (opts.options.MKSTREAM) {
                            command.push("MKSTREAM");
                        }
                        if (opts.options.ENTRIESREAD !== void 0) {
                            command.push("ENTRIESREAD", opts.options.ENTRIESREAD.toString());
                        }
                    }
                    break;
                }
            case "CREATECONSUMER":
                {
                    command.push("CREATECONSUMER", key, opts.group, opts.consumer);
                    break;
                }
            case "DELCONSUMER":
                {
                    command.push("DELCONSUMER", key, opts.group, opts.consumer);
                    break;
                }
            case "DESTROY":
                {
                    command.push("DESTROY", key, opts.group);
                    break;
                }
            case "SETID":
                {
                    command.push("SETID", key, opts.group, opts.id);
                    if (opts.options?.ENTRIESREAD !== void 0) {
                        command.push("ENTRIESREAD", opts.options.ENTRIESREAD.toString());
                    }
                    break;
                }
            default:
                {
                    throw new Error("Invalid XGROUP");
                }
        }
        super(command, commandOptions);
    }
};
// pkg/commands/xinfo.ts
var XInfoCommand = class extends Command {
    constructor([key, options], opts){
        const cmds = [];
        if (options.type === "CONSUMERS") {
            cmds.push("CONSUMERS", key, options.group);
        } else {
            cmds.push("GROUPS", key);
        }
        super([
            "XINFO",
            ...cmds
        ], opts);
    }
};
// pkg/commands/xlen.ts
var XLenCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "XLEN",
            ...cmd
        ], opts);
    }
};
// pkg/commands/xpending.ts
var XPendingCommand = class extends Command {
    constructor([key, group, start, end, count, options], opts){
        const consumers = options?.consumer === void 0 ? [] : Array.isArray(options.consumer) ? [
            ...options.consumer
        ] : [
            options.consumer
        ];
        super([
            "XPENDING",
            key,
            group,
            ...options?.idleTime ? [
                "IDLE",
                options.idleTime
            ] : [],
            start,
            end,
            count,
            ...consumers
        ], opts);
    }
};
// pkg/commands/xrange.ts
function deserialize4(result) {
    const obj = {};
    for (const e of result){
        for(let i = 0; i < e.length; i += 2){
            const streamId = e[i];
            const entries = e[i + 1];
            if (!(streamId in obj)) {
                obj[streamId] = {};
            }
            for(let j = 0; j < entries.length; j += 2){
                const field = entries[j];
                const value = entries[j + 1];
                try {
                    obj[streamId][field] = JSON.parse(value);
                } catch  {
                    obj[streamId][field] = value;
                }
            }
        }
    }
    return obj;
}
var XRangeCommand = class extends Command {
    constructor([key, start, end, count], opts){
        const command = [
            "XRANGE",
            key,
            start,
            end
        ];
        if (typeof count === "number") {
            command.push("COUNT", count);
        }
        super(command, {
            deserialize: (result)=>deserialize4(result),
            ...opts
        });
    }
};
// pkg/commands/xread.ts
var UNBALANCED_XREAD_ERR = "ERR Unbalanced XREAD list of streams: for each stream key an ID or '$' must be specified";
var XReadCommand = class extends Command {
    constructor([key, id, options], opts){
        if (Array.isArray(key) && Array.isArray(id) && key.length !== id.length) {
            throw new Error(UNBALANCED_XREAD_ERR);
        }
        const commands = [];
        if (typeof options?.count === "number") {
            commands.push("COUNT", options.count);
        }
        if (typeof options?.blockMS === "number") {
            commands.push("BLOCK", options.blockMS);
        }
        commands.push("STREAMS", ...Array.isArray(key) ? [
            ...key
        ] : [
            key
        ], ...Array.isArray(id) ? [
            ...id
        ] : [
            id
        ]);
        super([
            "XREAD",
            ...commands
        ], opts);
    }
};
// pkg/commands/xreadgroup.ts
var UNBALANCED_XREADGROUP_ERR = "ERR Unbalanced XREADGROUP list of streams: for each stream key an ID or '$' must be specified";
var XReadGroupCommand = class extends Command {
    constructor([group, consumer, key, id, options], opts){
        if (Array.isArray(key) && Array.isArray(id) && key.length !== id.length) {
            throw new Error(UNBALANCED_XREADGROUP_ERR);
        }
        const commands = [];
        if (typeof options?.count === "number") {
            commands.push("COUNT", options.count);
        }
        if (typeof options?.blockMS === "number") {
            commands.push("BLOCK", options.blockMS);
        }
        if (typeof options?.NOACK === "boolean" && options.NOACK) {
            commands.push("NOACK");
        }
        commands.push("STREAMS", ...Array.isArray(key) ? [
            ...key
        ] : [
            key
        ], ...Array.isArray(id) ? [
            ...id
        ] : [
            id
        ]);
        super([
            "XREADGROUP",
            "GROUP",
            group,
            consumer,
            ...commands
        ], opts);
    }
};
// pkg/commands/xrevrange.ts
var XRevRangeCommand = class extends Command {
    constructor([key, end, start, count], opts){
        const command = [
            "XREVRANGE",
            key,
            end,
            start
        ];
        if (typeof count === "number") {
            command.push("COUNT", count);
        }
        super(command, {
            deserialize: (result)=>deserialize5(result),
            ...opts
        });
    }
};
function deserialize5(result) {
    const obj = {};
    for (const e of result){
        for(let i = 0; i < e.length; i += 2){
            const streamId = e[i];
            const entries = e[i + 1];
            if (!(streamId in obj)) {
                obj[streamId] = {};
            }
            for(let j = 0; j < entries.length; j += 2){
                const field = entries[j];
                const value = entries[j + 1];
                try {
                    obj[streamId][field] = JSON.parse(value);
                } catch  {
                    obj[streamId][field] = value;
                }
            }
        }
    }
    return obj;
}
// pkg/commands/xtrim.ts
var XTrimCommand = class extends Command {
    constructor([key, options], opts){
        const { limit, strategy, threshold, exactness = "~" } = options;
        super([
            "XTRIM",
            key,
            strategy,
            exactness,
            threshold,
            ...limit ? [
                "LIMIT",
                limit
            ] : []
        ], opts);
    }
};
// pkg/commands/zadd.ts
var ZAddCommand = class extends Command {
    constructor([key, arg1, ...arg2], opts){
        const command = [
            "zadd",
            key
        ];
        if ("nx" in arg1 && arg1.nx) {
            command.push("nx");
        } else if ("xx" in arg1 && arg1.xx) {
            command.push("xx");
        }
        if ("ch" in arg1 && arg1.ch) {
            command.push("ch");
        }
        if ("incr" in arg1 && arg1.incr) {
            command.push("incr");
        }
        if ("lt" in arg1 && arg1.lt) {
            command.push("lt");
        } else if ("gt" in arg1 && arg1.gt) {
            command.push("gt");
        }
        if ("score" in arg1 && "member" in arg1) {
            command.push(arg1.score, arg1.member);
        }
        command.push(...arg2.flatMap(({ score, member })=>[
                score,
                member
            ]));
        super(command, opts);
    }
};
// pkg/commands/zcard.ts
var ZCardCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "zcard",
            ...cmd
        ], opts);
    }
};
// pkg/commands/zcount.ts
var ZCountCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "zcount",
            ...cmd
        ], opts);
    }
};
// pkg/commands/zincrby.ts
var ZIncrByCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "zincrby",
            ...cmd
        ], opts);
    }
};
// pkg/commands/zinterstore.ts
var ZInterStoreCommand = class extends Command {
    constructor([destination, numKeys, keyOrKeys, opts], cmdOpts){
        const command = [
            "zinterstore",
            destination,
            numKeys
        ];
        if (Array.isArray(keyOrKeys)) {
            command.push(...keyOrKeys);
        } else {
            command.push(keyOrKeys);
        }
        if (opts) {
            if ("weights" in opts && opts.weights) {
                command.push("weights", ...opts.weights);
            } else if ("weight" in opts && typeof opts.weight === "number") {
                command.push("weights", opts.weight);
            }
            if ("aggregate" in opts) {
                command.push("aggregate", opts.aggregate);
            }
        }
        super(command, cmdOpts);
    }
};
// pkg/commands/zlexcount.ts
var ZLexCountCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "zlexcount",
            ...cmd
        ], opts);
    }
};
// pkg/commands/zpopmax.ts
var ZPopMaxCommand = class extends Command {
    constructor([key, count], opts){
        const command = [
            "zpopmax",
            key
        ];
        if (typeof count === "number") {
            command.push(count);
        }
        super(command, opts);
    }
};
// pkg/commands/zpopmin.ts
var ZPopMinCommand = class extends Command {
    constructor([key, count], opts){
        const command = [
            "zpopmin",
            key
        ];
        if (typeof count === "number") {
            command.push(count);
        }
        super(command, opts);
    }
};
// pkg/commands/zrange.ts
var ZRangeCommand = class extends Command {
    constructor([key, min, max, opts], cmdOpts){
        const command = [
            "zrange",
            key,
            min,
            max
        ];
        if (opts?.byScore) {
            command.push("byscore");
        }
        if (opts?.byLex) {
            command.push("bylex");
        }
        if (opts?.rev) {
            command.push("rev");
        }
        if (opts?.count !== void 0 && opts.offset !== void 0) {
            command.push("limit", opts.offset, opts.count);
        }
        if (opts?.withScores) {
            command.push("withscores");
        }
        super(command, cmdOpts);
    }
};
// pkg/commands/zrank.ts
var ZRankCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "zrank",
            ...cmd
        ], opts);
    }
};
// pkg/commands/zrem.ts
var ZRemCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "zrem",
            ...cmd
        ], opts);
    }
};
// pkg/commands/zremrangebylex.ts
var ZRemRangeByLexCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "zremrangebylex",
            ...cmd
        ], opts);
    }
};
// pkg/commands/zremrangebyrank.ts
var ZRemRangeByRankCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "zremrangebyrank",
            ...cmd
        ], opts);
    }
};
// pkg/commands/zremrangebyscore.ts
var ZRemRangeByScoreCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "zremrangebyscore",
            ...cmd
        ], opts);
    }
};
// pkg/commands/zrevrank.ts
var ZRevRankCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "zrevrank",
            ...cmd
        ], opts);
    }
};
// pkg/commands/zscan.ts
var ZScanCommand = class extends Command {
    constructor([key, cursor, opts], cmdOpts){
        const command = [
            "zscan",
            key,
            cursor
        ];
        if (opts?.match) {
            command.push("match", opts.match);
        }
        if (typeof opts?.count === "number") {
            command.push("count", opts.count);
        }
        super(command, {
            deserialize: deserializeScanResponse,
            ...cmdOpts
        });
    }
};
// pkg/commands/zscore.ts
var ZScoreCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "zscore",
            ...cmd
        ], opts);
    }
};
// pkg/commands/zunion.ts
var ZUnionCommand = class extends Command {
    constructor([numKeys, keyOrKeys, opts], cmdOpts){
        const command = [
            "zunion",
            numKeys
        ];
        if (Array.isArray(keyOrKeys)) {
            command.push(...keyOrKeys);
        } else {
            command.push(keyOrKeys);
        }
        if (opts) {
            if ("weights" in opts && opts.weights) {
                command.push("weights", ...opts.weights);
            } else if ("weight" in opts && typeof opts.weight === "number") {
                command.push("weights", opts.weight);
            }
            if ("aggregate" in opts) {
                command.push("aggregate", opts.aggregate);
            }
            if (opts.withScores) {
                command.push("withscores");
            }
        }
        super(command, cmdOpts);
    }
};
// pkg/commands/zunionstore.ts
var ZUnionStoreCommand = class extends Command {
    constructor([destination, numKeys, keyOrKeys, opts], cmdOpts){
        const command = [
            "zunionstore",
            destination,
            numKeys
        ];
        if (Array.isArray(keyOrKeys)) {
            command.push(...keyOrKeys);
        } else {
            command.push(keyOrKeys);
        }
        if (opts) {
            if ("weights" in opts && opts.weights) {
                command.push("weights", ...opts.weights);
            } else if ("weight" in opts && typeof opts.weight === "number") {
                command.push("weights", opts.weight);
            }
            if ("aggregate" in opts) {
                command.push("aggregate", opts.aggregate);
            }
        }
        super(command, cmdOpts);
    }
};
// pkg/commands/zdiffstore.ts
var ZDiffStoreCommand = class extends Command {
    constructor(cmd, opts){
        super([
            "zdiffstore",
            ...cmd
        ], opts);
    }
};
// pkg/commands/zmscore.ts
var ZMScoreCommand = class extends Command {
    constructor(cmd, opts){
        const [key, members] = cmd;
        super([
            "zmscore",
            key,
            ...members
        ], opts);
    }
};
// pkg/pipeline.ts
var Pipeline = class {
    client;
    commands;
    commandOptions;
    multiExec;
    constructor(opts){
        this.client = opts.client;
        this.commands = [];
        this.commandOptions = opts.commandOptions;
        this.multiExec = opts.multiExec ?? false;
        if (this.commandOptions?.latencyLogging) {
            const originalExec = this.exec.bind(this);
            this.exec = async (options)=>{
                const start = performance.now();
                const result = await (options ? originalExec(options) : originalExec());
                const end = performance.now();
                const loggerResult = (end - start).toFixed(2);
                console.log(`Latency for \x1B[38;2;19;185;39m${this.multiExec ? [
                    "MULTI-EXEC"
                ] : [
                    "PIPELINE"
                ].toString().toUpperCase()}\x1B[0m: \x1B[38;2;0;255;255m${loggerResult} ms\x1B[0m`);
                return result;
            };
        }
    }
    exec = async (options)=>{
        if (this.commands.length === 0) {
            throw new Error("Pipeline is empty");
        }
        const path = this.multiExec ? [
            "multi-exec"
        ] : [
            "pipeline"
        ];
        const res = await this.client.request({
            path,
            body: Object.values(this.commands).map((c)=>c.command)
        });
        return options?.keepErrors ? res.map(({ error, result }, i)=>{
            return {
                error,
                result: this.commands[i].deserialize(result)
            };
        }) : res.map(({ error, result }, i)=>{
            if (error) {
                throw new UpstashError(`Command ${i + 1} [ ${this.commands[i].command[0]} ] failed: ${error}`);
            }
            return this.commands[i].deserialize(result);
        });
    };
    /**
   * Returns the length of pipeline before the execution
   */ length() {
        return this.commands.length;
    }
    /**
   * Pushes a command into the pipeline and returns a chainable instance of the
   * pipeline
   */ chain(command) {
        this.commands.push(command);
        return this;
    }
    /**
   * @see https://redis.io/commands/append
   */ append = (...args)=>this.chain(new AppendCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/bitcount
   */ bitcount = (...args)=>this.chain(new BitCountCommand(args, this.commandOptions));
    /**
   * Returns an instance that can be used to execute `BITFIELD` commands on one key.
   *
   * @example
   * ```typescript
   * redis.set("mykey", 0);
   * const result = await redis.pipeline()
   *   .bitfield("mykey")
   *   .set("u4", 0, 16)
   *   .incr("u4", "#1", 1)
   *   .exec();
   * console.log(result); // [[0, 1]]
   * ```
   *
   * @see https://redis.io/commands/bitfield
   */ bitfield = (...args)=>new BitFieldCommand(args, this.client, this.commandOptions, this.chain.bind(this));
    /**
   * @see https://redis.io/commands/bitop
   */ bitop = (op, destinationKey, sourceKey, ...sourceKeys)=>this.chain(new BitOpCommand([
            op,
            destinationKey,
            sourceKey,
            ...sourceKeys
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/bitpos
   */ bitpos = (...args)=>this.chain(new BitPosCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/copy
   */ copy = (...args)=>this.chain(new CopyCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/zdiffstore
   */ zdiffstore = (...args)=>this.chain(new ZDiffStoreCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/dbsize
   */ dbsize = ()=>this.chain(new DBSizeCommand(this.commandOptions));
    /**
   * @see https://redis.io/commands/decr
   */ decr = (...args)=>this.chain(new DecrCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/decrby
   */ decrby = (...args)=>this.chain(new DecrByCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/del
   */ del = (...args)=>this.chain(new DelCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/echo
   */ echo = (...args)=>this.chain(new EchoCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/eval_ro
   */ evalRo = (...args)=>this.chain(new EvalROCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/eval
   */ eval = (...args)=>this.chain(new EvalCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/evalsha_ro
   */ evalshaRo = (...args)=>this.chain(new EvalshaROCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/evalsha
   */ evalsha = (...args)=>this.chain(new EvalshaCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/exists
   */ exists = (...args)=>this.chain(new ExistsCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/expire
   */ expire = (...args)=>this.chain(new ExpireCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/expireat
   */ expireat = (...args)=>this.chain(new ExpireAtCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/flushall
   */ flushall = (args)=>this.chain(new FlushAllCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/flushdb
   */ flushdb = (...args)=>this.chain(new FlushDBCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/geoadd
   */ geoadd = (...args)=>this.chain(new GeoAddCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/geodist
   */ geodist = (...args)=>this.chain(new GeoDistCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/geopos
   */ geopos = (...args)=>this.chain(new GeoPosCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/geohash
   */ geohash = (...args)=>this.chain(new GeoHashCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/geosearch
   */ geosearch = (...args)=>this.chain(new GeoSearchCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/geosearchstore
   */ geosearchstore = (...args)=>this.chain(new GeoSearchStoreCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/get
   */ get = (...args)=>this.chain(new GetCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/getbit
   */ getbit = (...args)=>this.chain(new GetBitCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/getdel
   */ getdel = (...args)=>this.chain(new GetDelCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/getex
   */ getex = (...args)=>this.chain(new GetExCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/getrange
   */ getrange = (...args)=>this.chain(new GetRangeCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/getset
   */ getset = (key, value)=>this.chain(new GetSetCommand([
            key,
            value
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/hdel
   */ hdel = (...args)=>this.chain(new HDelCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/hexists
   */ hexists = (...args)=>this.chain(new HExistsCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/hexpire
   */ hexpire = (...args)=>this.chain(new HExpireCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/hexpireat
   */ hexpireat = (...args)=>this.chain(new HExpireAtCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/hexpiretime
   */ hexpiretime = (...args)=>this.chain(new HExpireTimeCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/httl
   */ httl = (...args)=>this.chain(new HTtlCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/hpexpire
   */ hpexpire = (...args)=>this.chain(new HPExpireCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/hpexpireat
   */ hpexpireat = (...args)=>this.chain(new HPExpireAtCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/hpexpiretime
   */ hpexpiretime = (...args)=>this.chain(new HPExpireTimeCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/hpttl
   */ hpttl = (...args)=>this.chain(new HPTtlCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/hpersist
   */ hpersist = (...args)=>this.chain(new HPersistCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/hget
   */ hget = (...args)=>this.chain(new HGetCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/hgetall
   */ hgetall = (...args)=>this.chain(new HGetAllCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/hincrby
   */ hincrby = (...args)=>this.chain(new HIncrByCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/hincrbyfloat
   */ hincrbyfloat = (...args)=>this.chain(new HIncrByFloatCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/hkeys
   */ hkeys = (...args)=>this.chain(new HKeysCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/hlen
   */ hlen = (...args)=>this.chain(new HLenCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/hmget
   */ hmget = (...args)=>this.chain(new HMGetCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/hmset
   */ hmset = (key, kv)=>this.chain(new HMSetCommand([
            key,
            kv
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/hrandfield
   */ hrandfield = (key, count, withValues)=>this.chain(new HRandFieldCommand([
            key,
            count,
            withValues
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/hscan
   */ hscan = (...args)=>this.chain(new HScanCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/hset
   */ hset = (key, kv)=>this.chain(new HSetCommand([
            key,
            kv
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/hsetnx
   */ hsetnx = (key, field, value)=>this.chain(new HSetNXCommand([
            key,
            field,
            value
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/hstrlen
   */ hstrlen = (...args)=>this.chain(new HStrLenCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/hvals
   */ hvals = (...args)=>this.chain(new HValsCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/incr
   */ incr = (...args)=>this.chain(new IncrCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/incrby
   */ incrby = (...args)=>this.chain(new IncrByCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/incrbyfloat
   */ incrbyfloat = (...args)=>this.chain(new IncrByFloatCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/keys
   */ keys = (...args)=>this.chain(new KeysCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/lindex
   */ lindex = (...args)=>this.chain(new LIndexCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/linsert
   */ linsert = (key, direction, pivot, value)=>this.chain(new LInsertCommand([
            key,
            direction,
            pivot,
            value
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/llen
   */ llen = (...args)=>this.chain(new LLenCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/lmove
   */ lmove = (...args)=>this.chain(new LMoveCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/lpop
   */ lpop = (...args)=>this.chain(new LPopCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/lmpop
   */ lmpop = (...args)=>this.chain(new LmPopCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/lpos
   */ lpos = (...args)=>this.chain(new LPosCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/lpush
   */ lpush = (key, ...elements)=>this.chain(new LPushCommand([
            key,
            ...elements
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/lpushx
   */ lpushx = (key, ...elements)=>this.chain(new LPushXCommand([
            key,
            ...elements
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/lrange
   */ lrange = (...args)=>this.chain(new LRangeCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/lrem
   */ lrem = (key, count, value)=>this.chain(new LRemCommand([
            key,
            count,
            value
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/lset
   */ lset = (key, index, value)=>this.chain(new LSetCommand([
            key,
            index,
            value
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/ltrim
   */ ltrim = (...args)=>this.chain(new LTrimCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/mget
   */ mget = (...args)=>this.chain(new MGetCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/mset
   */ mset = (kv)=>this.chain(new MSetCommand([
            kv
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/msetnx
   */ msetnx = (kv)=>this.chain(new MSetNXCommand([
            kv
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/persist
   */ persist = (...args)=>this.chain(new PersistCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/pexpire
   */ pexpire = (...args)=>this.chain(new PExpireCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/pexpireat
   */ pexpireat = (...args)=>this.chain(new PExpireAtCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/pfadd
   */ pfadd = (...args)=>this.chain(new PfAddCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/pfcount
   */ pfcount = (...args)=>this.chain(new PfCountCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/pfmerge
   */ pfmerge = (...args)=>this.chain(new PfMergeCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/ping
   */ ping = (args)=>this.chain(new PingCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/psetex
   */ psetex = (key, ttl, value)=>this.chain(new PSetEXCommand([
            key,
            ttl,
            value
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/pttl
   */ pttl = (...args)=>this.chain(new PTtlCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/publish
   */ publish = (...args)=>this.chain(new PublishCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/randomkey
   */ randomkey = ()=>this.chain(new RandomKeyCommand(this.commandOptions));
    /**
   * @see https://redis.io/commands/rename
   */ rename = (...args)=>this.chain(new RenameCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/renamenx
   */ renamenx = (...args)=>this.chain(new RenameNXCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/rpop
   */ rpop = (...args)=>this.chain(new RPopCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/rpush
   */ rpush = (key, ...elements)=>this.chain(new RPushCommand([
            key,
            ...elements
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/rpushx
   */ rpushx = (key, ...elements)=>this.chain(new RPushXCommand([
            key,
            ...elements
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/sadd
   */ sadd = (key, member, ...members)=>this.chain(new SAddCommand([
            key,
            member,
            ...members
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/scan
   */ scan = (...args)=>this.chain(new ScanCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/scard
   */ scard = (...args)=>this.chain(new SCardCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/script-exists
   */ scriptExists = (...args)=>this.chain(new ScriptExistsCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/script-flush
   */ scriptFlush = (...args)=>this.chain(new ScriptFlushCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/script-load
   */ scriptLoad = (...args)=>this.chain(new ScriptLoadCommand(args, this.commandOptions));
    /*)*
   * @see https://redis.io/commands/sdiff
   */ sdiff = (...args)=>this.chain(new SDiffCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/sdiffstore
   */ sdiffstore = (...args)=>this.chain(new SDiffStoreCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/set
   */ set = (key, value, opts)=>this.chain(new SetCommand([
            key,
            value,
            opts
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/setbit
   */ setbit = (...args)=>this.chain(new SetBitCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/setex
   */ setex = (key, ttl, value)=>this.chain(new SetExCommand([
            key,
            ttl,
            value
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/setnx
   */ setnx = (key, value)=>this.chain(new SetNxCommand([
            key,
            value
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/setrange
   */ setrange = (...args)=>this.chain(new SetRangeCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/sinter
   */ sinter = (...args)=>this.chain(new SInterCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/sinterstore
   */ sinterstore = (...args)=>this.chain(new SInterStoreCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/sismember
   */ sismember = (key, member)=>this.chain(new SIsMemberCommand([
            key,
            member
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/smembers
   */ smembers = (...args)=>this.chain(new SMembersCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/smismember
   */ smismember = (key, members)=>this.chain(new SMIsMemberCommand([
            key,
            members
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/smove
   */ smove = (source, destination, member)=>this.chain(new SMoveCommand([
            source,
            destination,
            member
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/spop
   */ spop = (...args)=>this.chain(new SPopCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/srandmember
   */ srandmember = (...args)=>this.chain(new SRandMemberCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/srem
   */ srem = (key, ...members)=>this.chain(new SRemCommand([
            key,
            ...members
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/sscan
   */ sscan = (...args)=>this.chain(new SScanCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/strlen
   */ strlen = (...args)=>this.chain(new StrLenCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/sunion
   */ sunion = (...args)=>this.chain(new SUnionCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/sunionstore
   */ sunionstore = (...args)=>this.chain(new SUnionStoreCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/time
   */ time = ()=>this.chain(new TimeCommand(this.commandOptions));
    /**
   * @see https://redis.io/commands/touch
   */ touch = (...args)=>this.chain(new TouchCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/ttl
   */ ttl = (...args)=>this.chain(new TtlCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/type
   */ type = (...args)=>this.chain(new TypeCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/unlink
   */ unlink = (...args)=>this.chain(new UnlinkCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/zadd
   */ zadd = (...args)=>{
        if ("score" in args[1]) {
            return this.chain(new ZAddCommand([
                args[0],
                args[1],
                ...args.slice(2)
            ], this.commandOptions));
        }
        return this.chain(new ZAddCommand([
            args[0],
            args[1],
            ...args.slice(2)
        ], this.commandOptions));
    };
    /**
   * @see https://redis.io/commands/xadd
   */ xadd = (...args)=>this.chain(new XAddCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/xack
   */ xack = (...args)=>this.chain(new XAckCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/xdel
   */ xdel = (...args)=>this.chain(new XDelCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/xgroup
   */ xgroup = (...args)=>this.chain(new XGroupCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/xread
   */ xread = (...args)=>this.chain(new XReadCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/xreadgroup
   */ xreadgroup = (...args)=>this.chain(new XReadGroupCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/xinfo
   */ xinfo = (...args)=>this.chain(new XInfoCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/xlen
   */ xlen = (...args)=>this.chain(new XLenCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/xpending
   */ xpending = (...args)=>this.chain(new XPendingCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/xclaim
   */ xclaim = (...args)=>this.chain(new XClaimCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/xautoclaim
   */ xautoclaim = (...args)=>this.chain(new XAutoClaim(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/xtrim
   */ xtrim = (...args)=>this.chain(new XTrimCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/xrange
   */ xrange = (...args)=>this.chain(new XRangeCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/xrevrange
   */ xrevrange = (...args)=>this.chain(new XRevRangeCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/zcard
   */ zcard = (...args)=>this.chain(new ZCardCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/zcount
   */ zcount = (...args)=>this.chain(new ZCountCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/zincrby
   */ zincrby = (key, increment, member)=>this.chain(new ZIncrByCommand([
            key,
            increment,
            member
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/zinterstore
   */ zinterstore = (...args)=>this.chain(new ZInterStoreCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/zlexcount
   */ zlexcount = (...args)=>this.chain(new ZLexCountCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/zmscore
   */ zmscore = (...args)=>this.chain(new ZMScoreCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/zpopmax
   */ zpopmax = (...args)=>this.chain(new ZPopMaxCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/zpopmin
   */ zpopmin = (...args)=>this.chain(new ZPopMinCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/zrange
   */ zrange = (...args)=>this.chain(new ZRangeCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/zrank
   */ zrank = (key, member)=>this.chain(new ZRankCommand([
            key,
            member
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/zrem
   */ zrem = (key, ...members)=>this.chain(new ZRemCommand([
            key,
            ...members
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/zremrangebylex
   */ zremrangebylex = (...args)=>this.chain(new ZRemRangeByLexCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/zremrangebyrank
   */ zremrangebyrank = (...args)=>this.chain(new ZRemRangeByRankCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/zremrangebyscore
   */ zremrangebyscore = (...args)=>this.chain(new ZRemRangeByScoreCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/zrevrank
   */ zrevrank = (key, member)=>this.chain(new ZRevRankCommand([
            key,
            member
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/zscan
   */ zscan = (...args)=>this.chain(new ZScanCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/zscore
   */ zscore = (key, member)=>this.chain(new ZScoreCommand([
            key,
            member
        ], this.commandOptions));
    /**
   * @see https://redis.io/commands/zunionstore
   */ zunionstore = (...args)=>this.chain(new ZUnionStoreCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/zunion
   */ zunion = (...args)=>this.chain(new ZUnionCommand(args, this.commandOptions));
    /**
   * @see https://redis.io/commands/?group=json
   */ get json() {
        return {
            /**
       * @see https://redis.io/commands/json.arrappend
       */ arrappend: (...args)=>this.chain(new JsonArrAppendCommand(args, this.commandOptions)),
            /**
       * @see https://redis.io/commands/json.arrindex
       */ arrindex: (...args)=>this.chain(new JsonArrIndexCommand(args, this.commandOptions)),
            /**
       * @see https://redis.io/commands/json.arrinsert
       */ arrinsert: (...args)=>this.chain(new JsonArrInsertCommand(args, this.commandOptions)),
            /**
       * @see https://redis.io/commands/json.arrlen
       */ arrlen: (...args)=>this.chain(new JsonArrLenCommand(args, this.commandOptions)),
            /**
       * @see https://redis.io/commands/json.arrpop
       */ arrpop: (...args)=>this.chain(new JsonArrPopCommand(args, this.commandOptions)),
            /**
       * @see https://redis.io/commands/json.arrtrim
       */ arrtrim: (...args)=>this.chain(new JsonArrTrimCommand(args, this.commandOptions)),
            /**
       * @see https://redis.io/commands/json.clear
       */ clear: (...args)=>this.chain(new JsonClearCommand(args, this.commandOptions)),
            /**
       * @see https://redis.io/commands/json.del
       */ del: (...args)=>this.chain(new JsonDelCommand(args, this.commandOptions)),
            /**
       * @see https://redis.io/commands/json.forget
       */ forget: (...args)=>this.chain(new JsonForgetCommand(args, this.commandOptions)),
            /**
       * @see https://redis.io/commands/json.get
       */ get: (...args)=>this.chain(new JsonGetCommand(args, this.commandOptions)),
            /**
       * @see https://redis.io/commands/json.merge
       */ merge: (...args)=>this.chain(new JsonMergeCommand(args, this.commandOptions)),
            /**
       * @see https://redis.io/commands/json.mget
       */ mget: (...args)=>this.chain(new JsonMGetCommand(args, this.commandOptions)),
            /**
       * @see https://redis.io/commands/json.mset
       */ mset: (...args)=>this.chain(new JsonMSetCommand(args, this.commandOptions)),
            /**
       * @see https://redis.io/commands/json.numincrby
       */ numincrby: (...args)=>this.chain(new JsonNumIncrByCommand(args, this.commandOptions)),
            /**
       * @see https://redis.io/commands/json.nummultby
       */ nummultby: (...args)=>this.chain(new JsonNumMultByCommand(args, this.commandOptions)),
            /**
       * @see https://redis.io/commands/json.objkeys
       */ objkeys: (...args)=>this.chain(new JsonObjKeysCommand(args, this.commandOptions)),
            /**
       * @see https://redis.io/commands/json.objlen
       */ objlen: (...args)=>this.chain(new JsonObjLenCommand(args, this.commandOptions)),
            /**
       * @see https://redis.io/commands/json.resp
       */ resp: (...args)=>this.chain(new JsonRespCommand(args, this.commandOptions)),
            /**
       * @see https://redis.io/commands/json.set
       */ set: (...args)=>this.chain(new JsonSetCommand(args, this.commandOptions)),
            /**
       * @see https://redis.io/commands/json.strappend
       */ strappend: (...args)=>this.chain(new JsonStrAppendCommand(args, this.commandOptions)),
            /**
       * @see https://redis.io/commands/json.strlen
       */ strlen: (...args)=>this.chain(new JsonStrLenCommand(args, this.commandOptions)),
            /**
       * @see https://redis.io/commands/json.toggle
       */ toggle: (...args)=>this.chain(new JsonToggleCommand(args, this.commandOptions)),
            /**
       * @see https://redis.io/commands/json.type
       */ type: (...args)=>this.chain(new JsonTypeCommand(args, this.commandOptions))
        };
    }
};
// pkg/auto-pipeline.ts
var EXCLUDE_COMMANDS = /* @__PURE__ */ new Set([
    "scan",
    "keys",
    "flushdb",
    "flushall",
    "dbsize",
    "hscan",
    "hgetall",
    "hkeys",
    "lrange",
    "sscan",
    "smembers",
    "xrange",
    "xrevrange",
    "zscan",
    "zrange",
    "exec"
]);
function createAutoPipelineProxy(_redis, json) {
    const redis = _redis;
    if (!redis.autoPipelineExecutor) {
        redis.autoPipelineExecutor = new AutoPipelineExecutor(redis);
    }
    return new Proxy(redis, {
        get: (redis2, command)=>{
            if (command === "pipelineCounter") {
                return redis2.autoPipelineExecutor.pipelineCounter;
            }
            if (command === "json") {
                return createAutoPipelineProxy(redis2, true);
            }
            const commandInRedisButNotPipeline = command in redis2 && !(command in redis2.autoPipelineExecutor.pipeline);
            const isCommandExcluded = EXCLUDE_COMMANDS.has(command);
            if (commandInRedisButNotPipeline || isCommandExcluded) {
                return redis2[command];
            }
            const isFunction = json ? typeof redis2.autoPipelineExecutor.pipeline.json[command] === "function" : typeof redis2.autoPipelineExecutor.pipeline[command] === "function";
            if (isFunction) {
                return (...args)=>{
                    return redis2.autoPipelineExecutor.withAutoPipeline((pipeline)=>{
                        if (json) {
                            pipeline.json[command](...args);
                        } else {
                            pipeline[command](...args);
                        }
                    });
                };
            }
            return redis2.autoPipelineExecutor.pipeline[command];
        }
    });
}
var AutoPipelineExecutor = class {
    pipelinePromises = /* @__PURE__ */ new WeakMap();
    activePipeline = null;
    indexInCurrentPipeline = 0;
    redis;
    pipeline;
    // only to make sure that proxy can work
    pipelineCounter = 0;
    // to keep track of how many times a pipeline was executed
    constructor(redis){
        this.redis = redis;
        this.pipeline = redis.pipeline();
    }
    async withAutoPipeline(executeWithPipeline) {
        const pipeline = this.activePipeline ?? this.redis.pipeline();
        if (!this.activePipeline) {
            this.activePipeline = pipeline;
            this.indexInCurrentPipeline = 0;
        }
        const index = this.indexInCurrentPipeline++;
        executeWithPipeline(pipeline);
        const pipelineDone = this.deferExecution().then(()=>{
            if (!this.pipelinePromises.has(pipeline)) {
                const pipelinePromise = pipeline.exec({
                    keepErrors: true
                });
                this.pipelineCounter += 1;
                this.pipelinePromises.set(pipeline, pipelinePromise);
                this.activePipeline = null;
            }
            return this.pipelinePromises.get(pipeline);
        });
        const results = await pipelineDone;
        const commandResult = results[index];
        if (commandResult.error) {
            throw new UpstashError(`Command failed: ${commandResult.error}`);
        }
        return commandResult.result;
    }
    async deferExecution() {
        await Promise.resolve();
        await Promise.resolve();
    }
};
// pkg/commands/psubscribe.ts
var PSubscribeCommand = class extends Command {
    constructor(cmd, opts){
        const sseHeaders = {
            Accept: "text/event-stream",
            "Cache-Control": "no-cache",
            Connection: "keep-alive"
        };
        super([], {
            ...opts,
            headers: sseHeaders,
            path: [
                "psubscribe",
                ...cmd
            ],
            streamOptions: {
                isStreaming: true,
                onMessage: opts?.streamOptions?.onMessage,
                signal: opts?.streamOptions?.signal
            }
        });
    }
};
// pkg/commands/subscribe.ts
var Subscriber = class extends EventTarget {
    subscriptions;
    client;
    listeners;
    opts;
    constructor(client, channels, isPattern = false, opts){
        super();
        this.client = client;
        this.subscriptions = /* @__PURE__ */ new Map();
        this.listeners = /* @__PURE__ */ new Map();
        this.opts = opts;
        for (const channel of channels){
            if (isPattern) {
                this.subscribeToPattern(channel);
            } else {
                this.subscribeToChannel(channel);
            }
        }
    }
    subscribeToChannel(channel) {
        const controller = new AbortController();
        const command = new SubscribeCommand([
            channel
        ], {
            streamOptions: {
                signal: controller.signal,
                onMessage: (data)=>this.handleMessage(data, false)
            }
        });
        command.exec(this.client).catch((error)=>{
            if (error.name !== "AbortError") {
                this.dispatchToListeners("error", error);
            }
        });
        this.subscriptions.set(channel, {
            command,
            controller,
            isPattern: false
        });
    }
    subscribeToPattern(pattern) {
        const controller = new AbortController();
        const command = new PSubscribeCommand([
            pattern
        ], {
            streamOptions: {
                signal: controller.signal,
                onMessage: (data)=>this.handleMessage(data, true)
            }
        });
        command.exec(this.client).catch((error)=>{
            if (error.name !== "AbortError") {
                this.dispatchToListeners("error", error);
            }
        });
        this.subscriptions.set(pattern, {
            command,
            controller,
            isPattern: true
        });
    }
    handleMessage(data, isPattern) {
        const messageData = data.replace(/^data:\s*/, "");
        const firstCommaIndex = messageData.indexOf(",");
        const secondCommaIndex = messageData.indexOf(",", firstCommaIndex + 1);
        const thirdCommaIndex = isPattern ? messageData.indexOf(",", secondCommaIndex + 1) : -1;
        if (firstCommaIndex !== -1 && secondCommaIndex !== -1) {
            const type = messageData.slice(0, firstCommaIndex);
            if (isPattern && type === "pmessage" && thirdCommaIndex !== -1) {
                const pattern = messageData.slice(firstCommaIndex + 1, secondCommaIndex);
                const channel = messageData.slice(secondCommaIndex + 1, thirdCommaIndex);
                const messageStr = messageData.slice(thirdCommaIndex + 1);
                try {
                    const message = this.opts?.automaticDeserialization === false ? messageStr : JSON.parse(messageStr);
                    this.dispatchToListeners("pmessage", {
                        pattern,
                        channel,
                        message
                    });
                    this.dispatchToListeners(`pmessage:${pattern}`, {
                        pattern,
                        channel,
                        message
                    });
                } catch (error) {
                    this.dispatchToListeners("error", new Error(`Failed to parse message: ${error}`));
                }
            } else {
                const channel = messageData.slice(firstCommaIndex + 1, secondCommaIndex);
                const messageStr = messageData.slice(secondCommaIndex + 1);
                try {
                    if (type === "subscribe" || type === "psubscribe" || type === "unsubscribe" || type === "punsubscribe") {
                        const count = Number.parseInt(messageStr);
                        this.dispatchToListeners(type, count);
                    } else {
                        const message = this.opts?.automaticDeserialization === false ? messageStr : parseWithTryCatch(messageStr);
                        this.dispatchToListeners(type, {
                            channel,
                            message
                        });
                        this.dispatchToListeners(`${type}:${channel}`, {
                            channel,
                            message
                        });
                    }
                } catch (error) {
                    this.dispatchToListeners("error", new Error(`Failed to parse message: ${error}`));
                }
            }
        }
    }
    dispatchToListeners(type, data) {
        const listeners = this.listeners.get(type);
        if (listeners) {
            for (const listener of listeners){
                listener(data);
            }
        }
    }
    on(type, listener) {
        if (!this.listeners.has(type)) {
            this.listeners.set(type, /* @__PURE__ */ new Set());
        }
        this.listeners.get(type)?.add(listener);
    }
    removeAllListeners() {
        this.listeners.clear();
    }
    async unsubscribe(channels) {
        if (channels) {
            for (const channel of channels){
                const subscription = this.subscriptions.get(channel);
                if (subscription) {
                    try {
                        subscription.controller.abort();
                    } catch  {}
                    this.subscriptions.delete(channel);
                }
            }
        } else {
            for (const subscription of this.subscriptions.values()){
                try {
                    subscription.controller.abort();
                } catch  {}
            }
            this.subscriptions.clear();
            this.removeAllListeners();
        }
    }
    getSubscribedChannels() {
        return [
            ...this.subscriptions.keys()
        ];
    }
};
var SubscribeCommand = class extends Command {
    constructor(cmd, opts){
        const sseHeaders = {
            Accept: "text/event-stream",
            "Cache-Control": "no-cache",
            Connection: "keep-alive"
        };
        super([], {
            ...opts,
            headers: sseHeaders,
            path: [
                "subscribe",
                ...cmd
            ],
            streamOptions: {
                isStreaming: true,
                onMessage: opts?.streamOptions?.onMessage,
                signal: opts?.streamOptions?.signal
            }
        });
    }
};
var parseWithTryCatch = (str)=>{
    try {
        return JSON.parse(str);
    } catch  {
        return str;
    }
};
;
var Script = class {
    script;
    /**
   * @deprecated This property is initialized to an empty string and will be set in the init method
   * asynchronously. Do not use this property immidiately after the constructor.
   *
   * This property is only exposed for backwards compatibility and will be removed in the
   * future major release.
   */ sha1;
    redis;
    constructor(redis, script){
        this.redis = redis;
        this.script = script;
        this.sha1 = "";
        void this.init(script);
    }
    /**
   * Initialize the script by computing its SHA-1 hash.
   */ async init(script) {
        if (this.sha1) return;
        this.sha1 = await this.digest(script);
    }
    /**
   * Send an `EVAL` command to redis.
   */ async eval(keys, args) {
        await this.init(this.script);
        return await this.redis.eval(this.script, keys, args);
    }
    /**
   * Calculates the sha1 hash of the script and then calls `EVALSHA`.
   */ async evalsha(keys, args) {
        await this.init(this.script);
        return await this.redis.evalsha(this.sha1, keys, args);
    }
    /**
   * Optimistically try to run `EVALSHA` first.
   * If the script is not loaded in redis, it will fall back and try again with `EVAL`.
   *
   * Following calls will be able to use the cached script
   */ async exec(keys, args) {
        await this.init(this.script);
        const res = await this.redis.evalsha(this.sha1, keys, args).catch(async (error)=>{
            if (error instanceof Error && error.message.toLowerCase().includes("noscript")) {
                return await this.redis.eval(this.script, keys, args);
            }
            throw error;
        });
        return res;
    }
    /**
   * Compute the sha1 hash of the script and return its hex representation.
   */ async digest(s) {
        const data = new TextEncoder().encode(s);
        const hashBuffer = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uncrypto$2f$dist$2f$crypto$2e$node$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["subtle"].digest("SHA-1", data);
        const hashArray = [
            ...new Uint8Array(hashBuffer)
        ];
        return hashArray.map((b)=>b.toString(16).padStart(2, "0")).join("");
    }
};
;
var ScriptRO = class {
    script;
    /**
   * @deprecated This property is initialized to an empty string and will be set in the init method
   * asynchronously. Do not use this property immidiately after the constructor.
   *
   * This property is only exposed for backwards compatibility and will be removed in the
   * future major release.
   */ sha1;
    redis;
    constructor(redis, script){
        this.redis = redis;
        this.sha1 = "";
        this.script = script;
        void this.init(script);
    }
    async init(script) {
        if (this.sha1) return;
        this.sha1 = await this.digest(script);
    }
    /**
   * Send an `EVAL_RO` command to redis.
   */ async evalRo(keys, args) {
        await this.init(this.script);
        return await this.redis.evalRo(this.script, keys, args);
    }
    /**
   * Calculates the sha1 hash of the script and then calls `EVALSHA_RO`.
   */ async evalshaRo(keys, args) {
        await this.init(this.script);
        return await this.redis.evalshaRo(this.sha1, keys, args);
    }
    /**
   * Optimistically try to run `EVALSHA_RO` first.
   * If the script is not loaded in redis, it will fall back and try again with `EVAL_RO`.
   *
   * Following calls will be able to use the cached script
   */ async exec(keys, args) {
        await this.init(this.script);
        const res = await this.redis.evalshaRo(this.sha1, keys, args).catch(async (error)=>{
            if (error instanceof Error && error.message.toLowerCase().includes("noscript")) {
                return await this.redis.evalRo(this.script, keys, args);
            }
            throw error;
        });
        return res;
    }
    /**
   * Compute the sha1 hash of the script and return its hex representation.
   */ async digest(s) {
        const data = new TextEncoder().encode(s);
        const hashBuffer = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uncrypto$2f$dist$2f$crypto$2e$node$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["subtle"].digest("SHA-1", data);
        const hashArray = [
            ...new Uint8Array(hashBuffer)
        ];
        return hashArray.map((b)=>b.toString(16).padStart(2, "0")).join("");
    }
};
// pkg/redis.ts
var Redis = class {
    client;
    opts;
    enableTelemetry;
    enableAutoPipelining;
    /**
   * Create a new redis client
   *
   * @example
   * ```typescript
   * const redis = new Redis({
   *  url: "<UPSTASH_REDIS_REST_URL>",
   *  token: "<UPSTASH_REDIS_REST_TOKEN>",
   * });
   * ```
   */ constructor(client, opts){
        this.client = client;
        this.opts = opts;
        this.enableTelemetry = opts?.enableTelemetry ?? true;
        if (opts?.readYourWrites === false) {
            this.client.readYourWrites = false;
        }
        this.enableAutoPipelining = opts?.enableAutoPipelining ?? true;
    }
    get readYourWritesSyncToken() {
        return this.client.upstashSyncToken;
    }
    set readYourWritesSyncToken(session) {
        this.client.upstashSyncToken = session;
    }
    get json() {
        return {
            /**
       * @see https://redis.io/commands/json.arrappend
       */ arrappend: (...args)=>new JsonArrAppendCommand(args, this.opts).exec(this.client),
            /**
       * @see https://redis.io/commands/json.arrindex
       */ arrindex: (...args)=>new JsonArrIndexCommand(args, this.opts).exec(this.client),
            /**
       * @see https://redis.io/commands/json.arrinsert
       */ arrinsert: (...args)=>new JsonArrInsertCommand(args, this.opts).exec(this.client),
            /**
       * @see https://redis.io/commands/json.arrlen
       */ arrlen: (...args)=>new JsonArrLenCommand(args, this.opts).exec(this.client),
            /**
       * @see https://redis.io/commands/json.arrpop
       */ arrpop: (...args)=>new JsonArrPopCommand(args, this.opts).exec(this.client),
            /**
       * @see https://redis.io/commands/json.arrtrim
       */ arrtrim: (...args)=>new JsonArrTrimCommand(args, this.opts).exec(this.client),
            /**
       * @see https://redis.io/commands/json.clear
       */ clear: (...args)=>new JsonClearCommand(args, this.opts).exec(this.client),
            /**
       * @see https://redis.io/commands/json.del
       */ del: (...args)=>new JsonDelCommand(args, this.opts).exec(this.client),
            /**
       * @see https://redis.io/commands/json.forget
       */ forget: (...args)=>new JsonForgetCommand(args, this.opts).exec(this.client),
            /**
       * @see https://redis.io/commands/json.get
       */ get: (...args)=>new JsonGetCommand(args, this.opts).exec(this.client),
            /**
       * @see https://redis.io/commands/json.merge
       */ merge: (...args)=>new JsonMergeCommand(args, this.opts).exec(this.client),
            /**
       * @see https://redis.io/commands/json.mget
       */ mget: (...args)=>new JsonMGetCommand(args, this.opts).exec(this.client),
            /**
       * @see https://redis.io/commands/json.mset
       */ mset: (...args)=>new JsonMSetCommand(args, this.opts).exec(this.client),
            /**
       * @see https://redis.io/commands/json.numincrby
       */ numincrby: (...args)=>new JsonNumIncrByCommand(args, this.opts).exec(this.client),
            /**
       * @see https://redis.io/commands/json.nummultby
       */ nummultby: (...args)=>new JsonNumMultByCommand(args, this.opts).exec(this.client),
            /**
       * @see https://redis.io/commands/json.objkeys
       */ objkeys: (...args)=>new JsonObjKeysCommand(args, this.opts).exec(this.client),
            /**
       * @see https://redis.io/commands/json.objlen
       */ objlen: (...args)=>new JsonObjLenCommand(args, this.opts).exec(this.client),
            /**
       * @see https://redis.io/commands/json.resp
       */ resp: (...args)=>new JsonRespCommand(args, this.opts).exec(this.client),
            /**
       * @see https://redis.io/commands/json.set
       */ set: (...args)=>new JsonSetCommand(args, this.opts).exec(this.client),
            /**
       * @see https://redis.io/commands/json.strappend
       */ strappend: (...args)=>new JsonStrAppendCommand(args, this.opts).exec(this.client),
            /**
       * @see https://redis.io/commands/json.strlen
       */ strlen: (...args)=>new JsonStrLenCommand(args, this.opts).exec(this.client),
            /**
       * @see https://redis.io/commands/json.toggle
       */ toggle: (...args)=>new JsonToggleCommand(args, this.opts).exec(this.client),
            /**
       * @see https://redis.io/commands/json.type
       */ type: (...args)=>new JsonTypeCommand(args, this.opts).exec(this.client)
        };
    }
    /**
   * Wrap a new middleware around the HTTP client.
   */ use = (middleware)=>{
        const makeRequest = this.client.request.bind(this.client);
        this.client.request = (req)=>middleware(req, makeRequest);
    };
    /**
   * Technically this is not private, we can hide it from intellisense by doing this
   */ addTelemetry = (telemetry)=>{
        if (!this.enableTelemetry) {
            return;
        }
        try {
            this.client.mergeTelemetry(telemetry);
        } catch  {}
    };
    /**
   * Creates a new script.
   *
   * Scripts offer the ability to optimistically try to execute a script without having to send the
   * entire script to the server. If the script is loaded on the server, it tries again by sending
   * the entire script. Afterwards, the script is cached on the server.
   *
   * @param script - The script to create
   * @param opts - Optional options to pass to the script `{ readonly?: boolean }`
   * @returns A new script
   *
   * @example
   * ```ts
   * const redis = new Redis({...})
   *
   * const script = redis.createScript<string>("return ARGV[1];")
   * const arg1 = await script.eval([], ["Hello World"])
   * expect(arg1, "Hello World")
   * ```
   * @example
   * ```ts
   * const redis = new Redis({...})
   *
   * const script = redis.createScript<string>("return ARGV[1];", { readonly: true })
   * const arg1 = await script.evalRo([], ["Hello World"])
   * expect(arg1, "Hello World")
   * ```
   */ createScript(script, opts) {
        return opts?.readonly ? new ScriptRO(this, script) : new Script(this, script);
    }
    /**
   * Create a new pipeline that allows you to send requests in bulk.
   *
   * @see {@link Pipeline}
   */ pipeline = ()=>new Pipeline({
            client: this.client,
            commandOptions: this.opts,
            multiExec: false
        });
    autoPipeline = ()=>{
        return createAutoPipelineProxy(this);
    };
    /**
   * Create a new transaction to allow executing multiple steps atomically.
   *
   * All the commands in a transaction are serialized and executed sequentially. A request sent by
   * another client will never be served in the middle of the execution of a Redis Transaction. This
   * guarantees that the commands are executed as a single isolated operation.
   *
   * @see {@link Pipeline}
   */ multi = ()=>new Pipeline({
            client: this.client,
            commandOptions: this.opts,
            multiExec: true
        });
    /**
   * Returns an instance that can be used to execute `BITFIELD` commands on one key.
   *
   * @example
   * ```typescript
   * redis.set("mykey", 0);
   * const result = await redis.bitfield("mykey")
   *   .set("u4", 0, 16)
   *   .incr("u4", "#1", 1)
   *   .exec();
   * console.log(result); // [0, 1]
   * ```
   *
   * @see https://redis.io/commands/bitfield
   */ bitfield = (...args)=>new BitFieldCommand(args, this.client, this.opts);
    /**
   * @see https://redis.io/commands/append
   */ append = (...args)=>new AppendCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/bitcount
   */ bitcount = (...args)=>new BitCountCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/bitop
   */ bitop = (op, destinationKey, sourceKey, ...sourceKeys)=>new BitOpCommand([
            op,
            destinationKey,
            sourceKey,
            ...sourceKeys
        ], this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/bitpos
   */ bitpos = (...args)=>new BitPosCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/copy
   */ copy = (...args)=>new CopyCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/dbsize
   */ dbsize = ()=>new DBSizeCommand(this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/decr
   */ decr = (...args)=>new DecrCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/decrby
   */ decrby = (...args)=>new DecrByCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/del
   */ del = (...args)=>new DelCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/echo
   */ echo = (...args)=>new EchoCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/eval_ro
   */ evalRo = (...args)=>new EvalROCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/eval
   */ eval = (...args)=>new EvalCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/evalsha_ro
   */ evalshaRo = (...args)=>new EvalshaROCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/evalsha
   */ evalsha = (...args)=>new EvalshaCommand(args, this.opts).exec(this.client);
    /**
   * Generic method to execute any Redis command.
   */ exec = (args)=>new ExecCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/exists
   */ exists = (...args)=>new ExistsCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/expire
   */ expire = (...args)=>new ExpireCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/expireat
   */ expireat = (...args)=>new ExpireAtCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/flushall
   */ flushall = (args)=>new FlushAllCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/flushdb
   */ flushdb = (...args)=>new FlushDBCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/geoadd
   */ geoadd = (...args)=>new GeoAddCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/geopos
   */ geopos = (...args)=>new GeoPosCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/geodist
   */ geodist = (...args)=>new GeoDistCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/geohash
   */ geohash = (...args)=>new GeoHashCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/geosearch
   */ geosearch = (...args)=>new GeoSearchCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/geosearchstore
   */ geosearchstore = (...args)=>new GeoSearchStoreCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/get
   */ get = (...args)=>new GetCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/getbit
   */ getbit = (...args)=>new GetBitCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/getdel
   */ getdel = (...args)=>new GetDelCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/getex
   */ getex = (...args)=>new GetExCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/getrange
   */ getrange = (...args)=>new GetRangeCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/getset
   */ getset = (key, value)=>new GetSetCommand([
            key,
            value
        ], this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/hdel
   */ hdel = (...args)=>new HDelCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/hexists
   */ hexists = (...args)=>new HExistsCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/hexpire
   */ hexpire = (...args)=>new HExpireCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/hexpireat
   */ hexpireat = (...args)=>new HExpireAtCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/hexpiretime
   */ hexpiretime = (...args)=>new HExpireTimeCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/httl
   */ httl = (...args)=>new HTtlCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/hpexpire
   */ hpexpire = (...args)=>new HPExpireCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/hpexpireat
   */ hpexpireat = (...args)=>new HPExpireAtCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/hpexpiretime
   */ hpexpiretime = (...args)=>new HPExpireTimeCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/hpttl
   */ hpttl = (...args)=>new HPTtlCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/hpersist
   */ hpersist = (...args)=>new HPersistCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/hget
   */ hget = (...args)=>new HGetCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/hgetall
   */ hgetall = (...args)=>new HGetAllCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/hincrby
   */ hincrby = (...args)=>new HIncrByCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/hincrbyfloat
   */ hincrbyfloat = (...args)=>new HIncrByFloatCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/hkeys
   */ hkeys = (...args)=>new HKeysCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/hlen
   */ hlen = (...args)=>new HLenCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/hmget
   */ hmget = (...args)=>new HMGetCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/hmset
   */ hmset = (key, kv)=>new HMSetCommand([
            key,
            kv
        ], this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/hrandfield
   */ hrandfield = (key, count, withValues)=>new HRandFieldCommand([
            key,
            count,
            withValues
        ], this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/hscan
   */ hscan = (...args)=>new HScanCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/hset
   */ hset = (key, kv)=>new HSetCommand([
            key,
            kv
        ], this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/hsetnx
   */ hsetnx = (key, field, value)=>new HSetNXCommand([
            key,
            field,
            value
        ], this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/hstrlen
   */ hstrlen = (...args)=>new HStrLenCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/hvals
   */ hvals = (...args)=>new HValsCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/incr
   */ incr = (...args)=>new IncrCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/incrby
   */ incrby = (...args)=>new IncrByCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/incrbyfloat
   */ incrbyfloat = (...args)=>new IncrByFloatCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/keys
   */ keys = (...args)=>new KeysCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/lindex
   */ lindex = (...args)=>new LIndexCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/linsert
   */ linsert = (key, direction, pivot, value)=>new LInsertCommand([
            key,
            direction,
            pivot,
            value
        ], this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/llen
   */ llen = (...args)=>new LLenCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/lmove
   */ lmove = (...args)=>new LMoveCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/lpop
   */ lpop = (...args)=>new LPopCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/lmpop
   */ lmpop = (...args)=>new LmPopCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/lpos
   */ lpos = (...args)=>new LPosCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/lpush
   */ lpush = (key, ...elements)=>new LPushCommand([
            key,
            ...elements
        ], this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/lpushx
   */ lpushx = (key, ...elements)=>new LPushXCommand([
            key,
            ...elements
        ], this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/lrange
   */ lrange = (...args)=>new LRangeCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/lrem
   */ lrem = (key, count, value)=>new LRemCommand([
            key,
            count,
            value
        ], this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/lset
   */ lset = (key, index, value)=>new LSetCommand([
            key,
            index,
            value
        ], this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/ltrim
   */ ltrim = (...args)=>new LTrimCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/mget
   */ mget = (...args)=>new MGetCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/mset
   */ mset = (kv)=>new MSetCommand([
            kv
        ], this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/msetnx
   */ msetnx = (kv)=>new MSetNXCommand([
            kv
        ], this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/persist
   */ persist = (...args)=>new PersistCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/pexpire
   */ pexpire = (...args)=>new PExpireCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/pexpireat
   */ pexpireat = (...args)=>new PExpireAtCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/pfadd
   */ pfadd = (...args)=>new PfAddCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/pfcount
   */ pfcount = (...args)=>new PfCountCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/pfmerge
   */ pfmerge = (...args)=>new PfMergeCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/ping
   */ ping = (args)=>new PingCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/psetex
   */ psetex = (key, ttl, value)=>new PSetEXCommand([
            key,
            ttl,
            value
        ], this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/psubscribe
   */ psubscribe = (patterns)=>{
        const patternArray = Array.isArray(patterns) ? patterns : [
            patterns
        ];
        return new Subscriber(this.client, patternArray, true, this.opts);
    };
    /**
   * @see https://redis.io/commands/pttl
   */ pttl = (...args)=>new PTtlCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/publish
   */ publish = (...args)=>new PublishCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/randomkey
   */ randomkey = ()=>new RandomKeyCommand().exec(this.client);
    /**
   * @see https://redis.io/commands/rename
   */ rename = (...args)=>new RenameCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/renamenx
   */ renamenx = (...args)=>new RenameNXCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/rpop
   */ rpop = (...args)=>new RPopCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/rpush
   */ rpush = (key, ...elements)=>new RPushCommand([
            key,
            ...elements
        ], this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/rpushx
   */ rpushx = (key, ...elements)=>new RPushXCommand([
            key,
            ...elements
        ], this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/sadd
   */ sadd = (key, member, ...members)=>new SAddCommand([
            key,
            member,
            ...members
        ], this.opts).exec(this.client);
    scan(cursor, opts) {
        return new ScanCommand([
            cursor,
            opts
        ], this.opts).exec(this.client);
    }
    /**
   * @see https://redis.io/commands/scard
   */ scard = (...args)=>new SCardCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/script-exists
   */ scriptExists = (...args)=>new ScriptExistsCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/script-flush
   */ scriptFlush = (...args)=>new ScriptFlushCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/script-load
   */ scriptLoad = (...args)=>new ScriptLoadCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/sdiff
   */ sdiff = (...args)=>new SDiffCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/sdiffstore
   */ sdiffstore = (...args)=>new SDiffStoreCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/set
   */ set = (key, value, opts)=>new SetCommand([
            key,
            value,
            opts
        ], this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/setbit
   */ setbit = (...args)=>new SetBitCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/setex
   */ setex = (key, ttl, value)=>new SetExCommand([
            key,
            ttl,
            value
        ], this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/setnx
   */ setnx = (key, value)=>new SetNxCommand([
            key,
            value
        ], this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/setrange
   */ setrange = (...args)=>new SetRangeCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/sinter
   */ sinter = (...args)=>new SInterCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/sinterstore
   */ sinterstore = (...args)=>new SInterStoreCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/sismember
   */ sismember = (key, member)=>new SIsMemberCommand([
            key,
            member
        ], this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/smismember
   */ smismember = (key, members)=>new SMIsMemberCommand([
            key,
            members
        ], this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/smembers
   */ smembers = (...args)=>new SMembersCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/smove
   */ smove = (source, destination, member)=>new SMoveCommand([
            source,
            destination,
            member
        ], this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/spop
   */ spop = (...args)=>new SPopCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/srandmember
   */ srandmember = (...args)=>new SRandMemberCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/srem
   */ srem = (key, ...members)=>new SRemCommand([
            key,
            ...members
        ], this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/sscan
   */ sscan = (...args)=>new SScanCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/strlen
   */ strlen = (...args)=>new StrLenCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/subscribe
   */ subscribe = (channels)=>{
        const channelArray = Array.isArray(channels) ? channels : [
            channels
        ];
        return new Subscriber(this.client, channelArray, false, this.opts);
    };
    /**
   * @see https://redis.io/commands/sunion
   */ sunion = (...args)=>new SUnionCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/sunionstore
   */ sunionstore = (...args)=>new SUnionStoreCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/time
   */ time = ()=>new TimeCommand().exec(this.client);
    /**
   * @see https://redis.io/commands/touch
   */ touch = (...args)=>new TouchCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/ttl
   */ ttl = (...args)=>new TtlCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/type
   */ type = (...args)=>new TypeCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/unlink
   */ unlink = (...args)=>new UnlinkCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/xadd
   */ xadd = (...args)=>new XAddCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/xack
   */ xack = (...args)=>new XAckCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/xdel
   */ xdel = (...args)=>new XDelCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/xgroup
   */ xgroup = (...args)=>new XGroupCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/xread
   */ xread = (...args)=>new XReadCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/xreadgroup
   */ xreadgroup = (...args)=>new XReadGroupCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/xinfo
   */ xinfo = (...args)=>new XInfoCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/xlen
   */ xlen = (...args)=>new XLenCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/xpending
   */ xpending = (...args)=>new XPendingCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/xclaim
   */ xclaim = (...args)=>new XClaimCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/xautoclaim
   */ xautoclaim = (...args)=>new XAutoClaim(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/xtrim
   */ xtrim = (...args)=>new XTrimCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/xrange
   */ xrange = (...args)=>new XRangeCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/xrevrange
   */ xrevrange = (...args)=>new XRevRangeCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/zadd
   */ zadd = (...args)=>{
        if ("score" in args[1]) {
            return new ZAddCommand([
                args[0],
                args[1],
                ...args.slice(2)
            ], this.opts).exec(this.client);
        }
        return new ZAddCommand([
            args[0],
            args[1],
            ...args.slice(2)
        ], this.opts).exec(this.client);
    };
    /**
   * @see https://redis.io/commands/zcard
   */ zcard = (...args)=>new ZCardCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/zcount
   */ zcount = (...args)=>new ZCountCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/zdiffstore
   */ zdiffstore = (...args)=>new ZDiffStoreCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/zincrby
   */ zincrby = (key, increment, member)=>new ZIncrByCommand([
            key,
            increment,
            member
        ], this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/zinterstore
   */ zinterstore = (...args)=>new ZInterStoreCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/zlexcount
   */ zlexcount = (...args)=>new ZLexCountCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/zmscore
   */ zmscore = (...args)=>new ZMScoreCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/zpopmax
   */ zpopmax = (...args)=>new ZPopMaxCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/zpopmin
   */ zpopmin = (...args)=>new ZPopMinCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/zrange
   */ zrange = (...args)=>new ZRangeCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/zrank
   */ zrank = (key, member)=>new ZRankCommand([
            key,
            member
        ], this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/zrem
   */ zrem = (key, ...members)=>new ZRemCommand([
            key,
            ...members
        ], this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/zremrangebylex
   */ zremrangebylex = (...args)=>new ZRemRangeByLexCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/zremrangebyrank
   */ zremrangebyrank = (...args)=>new ZRemRangeByRankCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/zremrangebyscore
   */ zremrangebyscore = (...args)=>new ZRemRangeByScoreCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/zrevrank
   */ zrevrank = (key, member)=>new ZRevRankCommand([
            key,
            member
        ], this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/zscan
   */ zscan = (...args)=>new ZScanCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/zscore
   */ zscore = (key, member)=>new ZScoreCommand([
            key,
            member
        ], this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/zunion
   */ zunion = (...args)=>new ZUnionCommand(args, this.opts).exec(this.client);
    /**
   * @see https://redis.io/commands/zunionstore
   */ zunionstore = (...args)=>new ZUnionStoreCommand(args, this.opts).exec(this.client);
};
// version.ts
var VERSION = "v1.35.7";
;
}),
"[project]/node_modules/@upstash/redis/nodejs.mjs [app-rsc] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Redis",
    ()=>Redis2
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$upstash$2f$redis$2f$chunk$2d$TBGBPMGD$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@upstash/redis/chunk-TBGBPMGD.mjs [app-rsc] (ecmascript)");
;
// platforms/nodejs.ts
if (typeof atob === "undefined") {
    /*TURBOPACK member replacement*/ __turbopack_context__.g.atob = (b64)=>Buffer.from(b64, "base64").toString("utf8");
}
var Redis2 = class _Redis extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$upstash$2f$redis$2f$chunk$2d$TBGBPMGD$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Redis"] {
    /**
   * Create a new redis client by providing a custom `Requester` implementation
   *
   * @example
   * ```ts
   *
   * import { UpstashRequest, Requester, UpstashResponse, Redis } from "@upstash/redis"
   *
   *  const requester: Requester = {
   *    request: <TResult>(req: UpstashRequest): Promise<UpstashResponse<TResult>> => {
   *      // ...
   *    }
   *  }
   *
   * const redis = new Redis(requester)
   * ```
   */ constructor(configOrRequester){
        if ("request" in configOrRequester) {
            super(configOrRequester);
            return;
        }
        if (!configOrRequester.url) {
            console.warn(`[Upstash Redis] The 'url' property is missing or undefined in your Redis config.`);
        } else if (configOrRequester.url.startsWith(" ") || configOrRequester.url.endsWith(" ") || /\r|\n/.test(configOrRequester.url)) {
            console.warn("[Upstash Redis] The redis url contains whitespace or newline, which can cause errors!");
        }
        if (!configOrRequester.token) {
            console.warn(`[Upstash Redis] The 'token' property is missing or undefined in your Redis config.`);
        } else if (configOrRequester.token.startsWith(" ") || configOrRequester.token.endsWith(" ") || /\r|\n/.test(configOrRequester.token)) {
            console.warn("[Upstash Redis] The redis token contains whitespace or newline, which can cause errors!");
        }
        const client = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$upstash$2f$redis$2f$chunk$2d$TBGBPMGD$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["HttpClient"]({
            baseUrl: configOrRequester.url,
            retry: configOrRequester.retry,
            headers: {
                authorization: `Bearer ${configOrRequester.token}`
            },
            agent: configOrRequester.agent,
            responseEncoding: configOrRequester.responseEncoding,
            cache: configOrRequester.cache ?? "no-store",
            signal: configOrRequester.signal,
            keepAlive: configOrRequester.keepAlive,
            readYourWrites: configOrRequester.readYourWrites
        });
        super(client, {
            automaticDeserialization: configOrRequester.automaticDeserialization,
            enableTelemetry: configOrRequester.enableTelemetry ?? !process.env.UPSTASH_DISABLE_TELEMETRY,
            latencyLogging: configOrRequester.latencyLogging,
            enableAutoPipelining: configOrRequester.enableAutoPipelining
        });
        this.addTelemetry({
            runtime: // @ts-expect-error to silence compiler
            typeof EdgeRuntime === "string" ? "edge-light" : `node@${process.version}`,
            platform: process.env.UPSTASH_CONSOLE ? "console" : process.env.VERCEL ? "vercel" : process.env.AWS_REGION ? "aws" : "unknown",
            sdk: `@upstash/redis@${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$upstash$2f$redis$2f$chunk$2d$TBGBPMGD$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["VERSION"]}`
        });
        if (this.enableAutoPipelining) {
            return this.autoPipeline();
        }
    }
    /**
   * Create a new Upstash Redis instance from environment variables.
   *
   * Use this to automatically load connection secrets from your environment
   * variables. For instance when using the Vercel integration.
   *
   * This tries to load connection details from your environment using `process.env`:
   * - URL: `UPSTASH_REDIS_REST_URL` or fallback to `KV_REST_API_URL`
   * - Token: `UPSTASH_REDIS_REST_TOKEN` or fallback to `KV_REST_API_TOKEN`
   *
   * The fallback variables provide compatibility with Vercel KV and other platforms
   * that may use different naming conventions.
   */ static fromEnv(config) {
        if (process.env === void 0) {
            throw new TypeError('[Upstash Redis] Unable to get environment variables, `process.env` is undefined. If you are deploying to cloudflare, please import from "@upstash/redis/cloudflare" instead');
        }
        const url = process.env.UPSTASH_REDIS_REST_URL || process.env.KV_REST_API_URL;
        if (!url) {
            console.warn("[Upstash Redis] Unable to find environment variable: `UPSTASH_REDIS_REST_URL`");
        }
        const token = process.env.UPSTASH_REDIS_REST_TOKEN || process.env.KV_REST_API_TOKEN;
        if (!token) {
            console.warn("[Upstash Redis] Unable to find environment variable: `UPSTASH_REDIS_REST_TOKEN`");
        }
        return new _Redis({
            ...config,
            url,
            token
        });
    }
};
;
}),
"[project]/node_modules/next/dist/build/webpack/loaders/next-flight-loader/action-validate.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// This function ensures that all the exported values are valid server actions,
// during the runtime. By definition all actions are required to be async
// functions, but here we can only check that they are functions.
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ensureServerEntryExports", {
    enumerable: true,
    get: function() {
        return ensureServerEntryExports;
    }
});
function ensureServerEntryExports(actions) {
    for(let i = 0; i < actions.length; i++){
        const action = actions[i];
        if (typeof action !== 'function') {
            throw Object.defineProperty(new Error(`A "use server" file can only export async functions, found ${typeof action}.\nRead more: https://nextjs.org/docs/messages/invalid-use-server-value`), "__NEXT_ERROR_CODE", {
                value: "E352",
                enumerable: false,
                configurable: true
            });
        }
    }
} //# sourceMappingURL=action-validate.js.map
}),
];

//# sourceMappingURL=node_modules_af56ef17._.js.map